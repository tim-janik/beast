// Licensed GNU LGPL v2.1 or later: http://www.gnu.org/licenses/lgpl.html
#include <bse/bseplugin.hh>
#include <bse/bseprocedure.hh>
#include <bse/bsesource.hh>
#include <bse/bseundostack.hh>
#include <bse/bseieee754.hh>
#include <bse/bsemidievent.hh>
#include "bsecxxplugin.hh"
#include "bsebuiltin_externs.cc"


AUTHORS	= "Tim Janik <timj@gtk.org>";
LICENSE = "GNU Lesser General Public License";

METHOD (BseSource, clear-inputs) {
  HELP	= "Disconnect all module inputs.";
  IN	= bse_param_spec_object ("module", "Module", NULL,
				 BSE_TYPE_SOURCE, SFI_PARAM_STANDARD);
}
BODY (BseProcedureClass *proc,
      const GValue      *in_values,
      GValue            *out_values)
{
  /* extract parameter values */
  BseSource *isource = (BseSource*) bse_value_get_object (in_values++);
  BseUndoStack *ustack;

  /* check parameters */
  if (!BSE_IS_SOURCE (isource))
    return Bse::Error::PROC_PARAM_INVAL;

  /* disconnect */
  ustack = bse_item_undo_open (isource, "clear-inputs %s", bse_object_debug_name (isource));
  bse_source_backup_ichannels_to_undo (isource);
  bse_item_push_redo_proc (isource, "clear-inputs");
  bse_item_undo_close (ustack);
  bse_source_clear_ichannels (isource);

  return Bse::Error::NONE;
}

METHOD (BseSource, clear-outputs) {
  HELP	= "Disconnect all module outputs.";
  IN	= bse_param_spec_object ("module", "Module", NULL,
				 BSE_TYPE_SOURCE, SFI_PARAM_STANDARD);
}
BODY (BseProcedureClass *proc,
      const GValue      *in_values,
      GValue            *out_values)
{
  /* extract parameter values */
  BseSource *isource = (BseSource*) bse_value_get_object (in_values++);
  BseUndoStack *ustack;

  /* check parameters */
  if (!BSE_IS_SOURCE (isource))
    return Bse::Error::PROC_PARAM_INVAL;

  /* disconnect */
  ustack = bse_item_undo_open (isource, "clear-outputs %s", bse_object_debug_name (isource));
  bse_source_backup_ochannels_to_undo (isource);
  bse_item_push_redo_proc (isource, "clear-outputs");
  bse_item_undo_close (ustack);
  bse_source_clear_ochannels (isource);

  return Bse::Error::NONE;
}

METHOD (BseSource, set-automation) {
  HELP	= "Setup automation parameters for a property.";
  IN	= bse_param_spec_object ("source", NULL, NULL,
				 BSE_TYPE_SOURCE, SFI_PARAM_STANDARD);
  IN    = sfi_pspec_string ("property_name", NULL, "Item property name",
                            NULL, SFI_PARAM_STANDARD);
  IN    = sfi_pspec_int ("midi_channel", _("MIDI Channel"), _("The MIDI Channel from which automation events should be received, 0 designates the default MIDI channel"),
                         0, 0, BSE_MIDI_MAX_CHANNELS, 1, SFI_PARAM_STANDARD ":scale:unprepared");
  IN    = bse_param_spec_genum ("control_type", _("Control Type"), _("The type of control events used for automation"),
                                BSE_TYPE_MIDI_CONTROL_TYPE, BSE_MIDI_CONTROL_CONTINUOUS_16, SFI_PARAM_STANDARD);
  OUT   = bse_param_spec_genum ("error", "Error", NULL, BSE_TYPE_ERROR_TYPE, Bse::Error::NONE, SFI_PARAM_STANDARD);
}
BODY (BseProcedureClass *proc,
      const GValue      *in_values,
      GValue            *out_values)
{
  /* extract parameter values */
  BseSource *source = (BseSource*) bse_value_get_object (in_values++);
  const char *property = sfi_value_get_string (in_values++);
  guint      midi_channel = sfi_value_get_int (in_values++);
  Bse::MidiSignal control_type = (Bse::MidiSignal) g_value_get_enum (in_values++);
  Bse::Error error = Bse::Error::NONE;

  /* check parameters */
  if (!BSE_IS_SOURCE (source) || !property)
    return Bse::Error::PROC_PARAM_INVAL;

  /* connect */
  guint old_midi_channel = 0;
  Bse::MidiSignal old_control_type = Bse::MidiSignal (0);
  bse_source_get_automation_property (source, property, &old_midi_channel, &old_control_type);
  if (old_midi_channel != midi_channel || old_control_type != control_type)
    {
      error = bse_source_set_automation_property (source, property, midi_channel, control_type);
      if (error == Bse::Error::NONE)
        bse_item_push_undo_proc (source, "set-automation", property, old_midi_channel, old_control_type);
    }

  /* set output parameters */
  g_value_set_enum (out_values++, int (error));

  return Bse::Error::NONE;
}

METHOD (BseSource, get-automation-channel) {
  HELP	= "Get MIDI channel from an automation property.";
  IN	= bse_param_spec_object ("source", NULL, NULL,
				 BSE_TYPE_SOURCE, SFI_PARAM_STANDARD);
  IN    = sfi_pspec_string ("property_name", NULL, "Item property name",
                            NULL, SFI_PARAM_STANDARD);
  OUT   = sfi_pspec_int ("midi_channel", NULL, NULL, 0, 0, BSE_MIDI_MAX_CHANNELS, 1, SFI_PARAM_STANDARD ":scale:unprepared");
}
BODY (BseProcedureClass *proc,
      const GValue      *in_values,
      GValue            *out_values)
{
  /* extract parameter values */
  BseSource *source = (BseSource*) bse_value_get_object (in_values++);
  const char *property = sfi_value_get_string (in_values++);

  /* check parameters */
  if (!BSE_IS_SOURCE (source) || !property)
    return Bse::Error::PROC_PARAM_INVAL;

  /* connect */
  guint midi_channel = 0;
  bse_source_get_automation_property (source, property, &midi_channel, NULL);
  /* set output parameters */
  g_value_set_int (out_values++, midi_channel);

  return Bse::Error::NONE;
}

METHOD (BseSource, get-automation-control) {
  HELP	= "Get control type from an automation property.";
  IN	= bse_param_spec_object ("source", NULL, NULL,
				 BSE_TYPE_SOURCE, SFI_PARAM_STANDARD);
  IN    = sfi_pspec_string ("property_name", NULL, "Item property name",
                            NULL, SFI_PARAM_STANDARD);
  OUT   = bse_param_spec_genum ("control_type", NULL, NULL, BSE_TYPE_MIDI_CONTROL_TYPE, BSE_MIDI_CONTROL_CONTINUOUS_16, SFI_PARAM_STANDARD);
}
BODY (BseProcedureClass *proc,
      const GValue      *in_values,
      GValue            *out_values)
{
  /* extract parameter values */
  BseSource *source = (BseSource*) bse_value_get_object (in_values++);
  const char *property = sfi_value_get_string (in_values++);

  /* check parameters */
  if (!BSE_IS_SOURCE (source) || !property)
    return Bse::Error::PROC_PARAM_INVAL;

  /* connect */
  Bse::MidiSignal control_type = Bse::MidiSignal (0);
  bse_source_get_automation_property (source, property, NULL, &control_type);
  /* set output parameters */
  g_value_set_enum (out_values++, int (control_type));

  return Bse::Error::NONE;
}
