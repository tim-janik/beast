// Licensed GNU LGPL v2.1 or later: http://www.gnu.org/licenses/lgpl.html -*-mode:c++;-*-
/**
 * @file
 * @brief Public BSE interface classes.
 */

namespace Bse {

// == Type Constants ==
Const MAXINT63   = +9223372036854775807;
Const MAXINT32   = +4294967295;
Const MAXINT31   = +2147483647;
Const MININT31   = -2147483648;
Const MAXFLOAT64 = 1.7976931348623157e+308;

// == Enums ==
enum Error {
  NONE                      = Enum (0, "", _("OK")),
  INTERNAL                  = Enum (11, "", _("Internal error (please report)")),
  UNKNOWN                   = Enum (12, "", _("Unknown error")),
  IO                        = Enum (13, "", _("Input/output error")),
  PERMS                     = Enum (14, "", _("Insufficient permissions")),
  // out of resource conditions
  NO_MEMORY                 = Enum (101, "", _("Out of memory")),
  MANY_FILES                = Enum (102, "", _("Too many open files")),
  NO_FILES                  = Enum (103, "", _("Too many open files in system")),
  NO_SPACE                  = Enum (104, "", _("No space left on device")),
  // file errors
  FILE_BUSY                 = Enum (201, "", _("Device or resource busy")),
  FILE_EXISTS               = Enum (202, "", _("File exists already")),
  FILE_EOF                  = Enum (203, "", _("End of file")),
  FILE_EMPTY                = Enum (204, "", _("File empty")),
  FILE_NOT_FOUND            = Enum (205, "", _("No such file, device or directory")),
  FILE_IS_DIR               = Enum (206, "", _("Is a directory")),
  FILE_OPEN_FAILED          = Enum (207, "", _("Open failed")),
  FILE_SEEK_FAILED          = Enum (208, "", _("Seek failed")),
  FILE_READ_FAILED          = Enum (209, "", _("Read failed")),
  FILE_WRITE_FAILED         = Enum (210, "", _("Write failed")),
  // content errors
  NO_HEADER                 = Enum (301, "", _("Failed to detect header")),
  NO_SEEK_INFO              = Enum (302, "", _("Failed to retrieve seek information")),
  NO_DATA_AVAILABLE         = Enum (303, "", _("No data available")),
  DATA_CORRUPT              = Enum (304, "", _("Data corrupt")),
  WRONG_N_CHANNELS          = Enum (305, "", _("Wrong number of channels")),
  FORMAT_INVALID            = Enum (306, "", _("Invalid format")),
  FORMAT_UNKNOWN            = Enum (307, "", _("Unknown format")),
  DATA_UNMATCHED            = Enum (308, "", _("Requested data values unmatched")),
  // Device errors
  DEVICE_NOT_AVAILABLE      = Enum (601, "", _("No device (driver) available")),
  DEVICE_ASYNC              = Enum (602, "", _("Device not async capable")),
  DEVICE_BUSY               = Enum (603, "", _("Device busy")),
  DEVICE_FORMAT             = Enum (604, "", _("Failed to configure device format")),
  DEVICE_BUFFER             = Enum (605, "", _("Failed to configure device buffer")),
  DEVICE_LATENCY            = Enum (606, "", _("Failed to configure device latency")),
  DEVICE_CHANNELS           = Enum (607, "", _("Failed to configure number of device channels")),
  DEVICE_FREQUENCY          = Enum (608, "", _("Failed to configure device frequency")),
  DEVICES_MISMATCH          = Enum (609, "", _("Device configurations mismatch")),
  // BseSource errors
  SOURCE_NO_SUCH_MODULE     = Enum (701, "", _("No such synthesis module")),
  SOURCE_NO_SUCH_ICHANNEL   = Enum (702, "", _("No such input channel")),
  SOURCE_NO_SUCH_OCHANNEL   = Enum (703, "", _("No such output channel")),
  SOURCE_NO_SUCH_CONNECTION = Enum (704, "", _("Input/Output channels not connected")),
  SOURCE_PRIVATE_ICHANNEL   = Enum (705, "", _("Input channel is private")),
  SOURCE_ICHANNEL_IN_USE    = Enum (706, "", _("Input channel already in use")),
  SOURCE_CHANNELS_CONNECTED = Enum (707, "", _("Input/output channels already connected")),
  SOURCE_CONNECTION_INVALID = Enum (708, "", _("Invalid synthesis module connection")),
  SOURCE_PARENT_MISMATCH    = Enum (709, "", _("Parent mismatch")),
  SOURCE_BAD_LOOPBACK       = Enum (710, "", _("Bad loopback")),
  SOURCE_BUSY               = Enum (711, "", _("Synthesis module currently busy")),
  SOURCE_TYPE_INVALID       = Enum (712, "", _("Invalid synthsis module type")),
  // miscellaneous errors
  TEMP                      = Enum (901, "", _("Temporary error")),
  WAVE_NOT_FOUND            = Enum (902, "", _("No such wave")),
  CODEC_FAILURE             = Enum (903, "", _("Codec failure")),
  UNIMPLEMENTED             = Enum (904, "", _("Functionality not implemented")),
  INVALID_PROPERTY          = Enum (905, "", _("Invalid object property")),
  INVALID_MIDI_CONTROL      = Enum (906, "", _("Invalid MIDI control type")),
  PARSE_ERROR               = Enum (907, "", _("Parsing error")),
  SPAWN                     = Enum (908, "", _("Failed to spawn child process")),
  // BseProcedure errors
  PROC_NOT_FOUND            = Enum (956, "", _("No such procedure")),
  PROC_BUSY                 = Enum (957, "", _("Procedure currently busy")),
  PROC_PARAM_INVAL          = Enum (958, "", _("Procedure parameter invalid")),
  PROC_EXECUTION            = Enum (959, "", _("Procedure execution failed")),
  PROC_ABORT                = Enum (960, "", _("Procedure execution aborted")),
  // various procedure errors
  NO_ENTRY                  = Enum (961, "", _("No such entry")),
  NO_EVENT                  = Enum (962, "", _("No such event")),
  NO_TARGET                 = Enum (963, "", _("No target")),
  NOT_OWNER                 = Enum (964, "", _("Ownership mismatch")),
  INVALID_OFFSET            = Enum (965, "", _("Invalid offset")),
  INVALID_DURATION          = Enum (966, "", _("Invalid duration")),
  INVALID_OVERLAP           = Enum (967, "", _("Invalid overlap")),
};

enum MidiSignal {
  // special case signals
  PROGRAM                   = Enum (1,   _("Program Change")),     // 7bit
  PRESSURE                  = Enum (2,   _("Channel Pressure")),   // 7bit
  PITCH_BEND                = Enum (3,   _("Pitch Bend")),         // 14bit
  VELOCITY                  = Enum (4,   _("Note Velocity")),
  FINE_TUNE                 = Enum (5,   _("Note Fine Tune")),
  // 14bit, continuous controls
  CONTINUOUS_0              = Enum (64,  _("Bank Select")),
  CONTINUOUS_1              = Enum (65,  _("Modulation Depth")),
  CONTINUOUS_2              = Enum (66,  _("Breath Control")),
  CONTINUOUS_3              = Enum (67,  _("Continuous 3")),
  CONTINUOUS_4              = Enum (68,  _("Foot Controller")),
  CONTINUOUS_5              = Enum (69,  _("Portamento Time")),
  CONTINUOUS_6              = Enum (70,  _("Data Entry")),
  CONTINUOUS_7              = Enum (71,  _("Volume")),
  CONTINUOUS_8              = Enum (72,  _("Balance")),
  CONTINUOUS_9              = Enum (73,  _("Continuous 9")),
  CONTINUOUS_10             = Enum (74,  _("Panorama")),
  CONTINUOUS_11             = Enum (75,  _("Expression")),
  CONTINUOUS_12             = Enum (76,  _("Effect Control 1")),
  CONTINUOUS_13             = Enum (77,  _("Effect Control 2")),
  CONTINUOUS_14             = Enum (78,  _("Continuous 14")),
  CONTINUOUS_15             = Enum (79,  _("Continuous 15")),
  CONTINUOUS_16             = Enum (80,  _("General Purpose Controller 1")),
  CONTINUOUS_17             = Enum (81,  _("General Purpose Controller 2")),
  CONTINUOUS_18             = Enum (82,  _("General Purpose Controller 3")),
  CONTINUOUS_19             = Enum (83,  _("General Purpose Controller 4")),
  CONTINUOUS_20             = Enum (84,  _("Continuous 20")),
  CONTINUOUS_21             = Enum (85,  _("Continuous 21")),
  CONTINUOUS_22             = Enum (86,  _("Continuous 22")),
  CONTINUOUS_23             = Enum (87,  _("Continuous 23")),
  CONTINUOUS_24             = Enum (88,  _("Continuous 24")),
  CONTINUOUS_25             = Enum (89,  _("Continuous 25")),
  CONTINUOUS_26             = Enum (90,  _("Continuous 26")),
  CONTINUOUS_27             = Enum (91,  _("Continuous 27")),
  CONTINUOUS_28             = Enum (92,  _("Continuous 28")),
  CONTINUOUS_29             = Enum (93,  _("Continuous 29")),
  CONTINUOUS_30             = Enum (94,  _("Continuous 30")),
  CONTINUOUS_31             = Enum (95,  _("Continuous 31")),
  // 14bit, special case signals
  CONSTANT_HIGH             = Enum (96,  _("Constant HIGH")),
  CONSTANT_CENTER           = Enum (97,  _("Constant CENTER")),
  CONSTANT_LOW              = Enum (98,  _("Constant LOW")),
  CONSTANT_NEGATIVE_CENTER  = Enum (99,  _("Constant Negative CENTER")),
  CONSTANT_NEGATIVE_HIGH    = Enum (100, _("Constant Negative HIGH")),
  PARAMETER                 = Enum (101, _("Registered Parameter")),
  NON_PARAMETER             = Enum (102, _("Non-Registered Parameter")),
  // 7bit, literal channel controls, MSB values
  CONTROL_0                 = Enum (128, _("Control 0 Bank Select MSB")),
  CONTROL_1                 = Enum (129, _("Control 1 Modulation Depth MSB")),
  CONTROL_2                 = Enum (130, _("Control 2 Breath Control MSB")),
  CONTROL_3                 = Enum (131, _("control-3")),
  CONTROL_4                 = Enum (132, _("Control 4 Foot Controller MSB")),
  CONTROL_5                 = Enum (133, _("Control 5 Portamento Time MSB")),
  CONTROL_6                 = Enum (134, _("Control 6 Data Entry MSB")),
  CONTROL_7                 = Enum (135, _("Control 7 Volume MSB")),
  CONTROL_8                 = Enum (136, _("Control 8 Balance MSB")),
  CONTROL_9                 = Enum (137, _("control-9")),
  CONTROL_10                = Enum (138, _("Control 10 Panorama MSB")),
  CONTROL_11                = Enum (139, _("Control 11 Expression MSB")),
  CONTROL_12                = Enum (140, _("Control 12 Effect Control 1 MSB")),
  CONTROL_13                = Enum (141, _("Control 13 Effect Control 2 MSB")),
  CONTROL_14                = Enum (142, _("control-14")),
  CONTROL_15                = Enum (143, _("control-15")),
  CONTROL_16                = Enum (144, _("Control 16 General Purpose Controller 1 MSB")),
  CONTROL_17                = Enum (145, _("Control 17 General Purpose Controller 2 MSB")),
  CONTROL_18                = Enum (146, _("Control 18 General Purpose Controller 3 MSB")),
  CONTROL_19                = Enum (147, _("Control 19 General Purpose Controller 4 MSB")),
  CONTROL_20                = Enum (148, _("control-20")),
  CONTROL_21                = Enum (149, _("control-21")),
  CONTROL_22                = Enum (150, _("control-22")),
  CONTROL_23                = Enum (151, _("control-23")),
  CONTROL_24                = Enum (152, _("control-24")),
  CONTROL_25                = Enum (153, _("control-25")),
  CONTROL_26                = Enum (154, _("control-26")),
  CONTROL_27                = Enum (155, _("control-27")),
  CONTROL_28                = Enum (156, _("control-28")),
  CONTROL_29                = Enum (157, _("control-29")),
  CONTROL_30                = Enum (158, _("control-30")),
  CONTROL_31                = Enum (159, _("control-31")),
  // 7bit, literal channel controls, LSB values
  CONTROL_32                = Enum (160, _("Control 32 Bank Select LSB")),
  CONTROL_33                = Enum (161, _("Control 33 Modulation Depth LSB")),
  CONTROL_34                = Enum (162, _("Control 34 Breath Control LSB")),
  CONTROL_35                = Enum (163, _("control-35")),
  CONTROL_36                = Enum (164, _("Control 36 Foot Controller LSB")),
  CONTROL_37                = Enum (165, _("Control 37 Portamento Time LSB")),
  CONTROL_38                = Enum (166, _("Control 38 Data Entry LSB")),
  CONTROL_39                = Enum (167, _("Control 39 Volume LSB")),
  CONTROL_40                = Enum (168, _("Control 40 Balance LSB")),
  CONTROL_41                = Enum (169, _("control-41")),
  CONTROL_42                = Enum (170, _("Control 42 Panorama LSB")),
  CONTROL_43                = Enum (171, _("Control 43 Expression LSB")),
  CONTROL_44                = Enum (172, _("Control 44 Effect Control 1 LSB")),
  CONTROL_45                = Enum (173, _("Control 45 Effect Control 2 LSB")),
  CONTROL_46                = Enum (174, _("control-46")),
  CONTROL_47                = Enum (175, _("control-47")),
  CONTROL_48                = Enum (176, _("Control 48 General Purpose Controller 1 LSB")),
  CONTROL_49                = Enum (177, _("Control 49 General Purpose Controller 2 LSB")),
  CONTROL_50                = Enum (178, _("Control 50 General Purpose Controller 3 LSB")),
  CONTROL_51                = Enum (179, _("Control 51 General Purpose Controller 4 LSB")),
  CONTROL_52                = Enum (180, _("control-52")),
  CONTROL_53                = Enum (181, _("control-53")),
  CONTROL_54                = Enum (182, _("control-54")),
  CONTROL_55                = Enum (183, _("control-55")),
  CONTROL_56                = Enum (184, _("control-56")),
  CONTROL_57                = Enum (185, _("control-57")),
  CONTROL_58                = Enum (186, _("control-58")),
  CONTROL_59                = Enum (187, _("control-59")),
  CONTROL_60                = Enum (188, _("control-60")),
  CONTROL_61                = Enum (189, _("control-61")),
  CONTROL_62                = Enum (190, _("control-62")),
  CONTROL_63                = Enum (191, _("control-63")),
  // 7bit, literal channel controls
  CONTROL_64                = Enum (192, _("Control 64 Damper Pedal Switch (Sustain)")),
  CONTROL_65                = Enum (193, _("Control 65 Portamento Switch")),
  CONTROL_66                = Enum (194, _("Control 66 Sustenuto Switch")),
  CONTROL_67                = Enum (195, _("Control 67 Soft Switch")),
  CONTROL_68                = Enum (196, _("Control 68 Legato Pedal Switch")),
  CONTROL_69                = Enum (197, _("Control 69 Hold Pedal Switch")),
  CONTROL_70                = Enum (198, _("Control 70 Sound Variation")),
  CONTROL_71                = Enum (199, _("Control 71 Filter Resonance (Timbre)")),
  CONTROL_72                = Enum (200, _("Control 72 Sound Release Time")),
  CONTROL_73                = Enum (201, _("Control 73 Sound Attack Time")),
  CONTROL_74                = Enum (202, _("Control 74 Sound Brightness")),
  CONTROL_75                = Enum (203, _("Control 75 Sound Decay Time")),
  CONTROL_76                = Enum (204, _("Control 76 Vibrato Rate")),
  CONTROL_77                = Enum (205, _("Control 77 Vibrato Depth")),
  CONTROL_78                = Enum (206, _("Control 78 Vibrato Delay")),
  CONTROL_79                = Enum (207, _("Control 79 Sound Control 10")),
  CONTROL_80                = Enum (208, _("Control 80 General Purpose Switch 5")),
  CONTROL_81                = Enum (209, _("Control 81 General Purpose Switch 6")),
  CONTROL_82                = Enum (210, _("Control 82 General Purpose Switch 7")),
  CONTROL_83                = Enum (211, _("Control 83 General Purpose Switch 8")),
  CONTROL_84                = Enum (212, _("Control 84 Portamento Control (Note)")),
  CONTROL_85                = Enum (213, _("control-85")),
  CONTROL_86                = Enum (214, _("control-86")),
  CONTROL_87                = Enum (215, _("control-87")),
  CONTROL_88                = Enum (216, _("control-88")),
  CONTROL_89                = Enum (217, _("control-89")),
  CONTROL_90                = Enum (218, _("control-90")),
  CONTROL_91                = Enum (219, _("Control 91 Reverb Depth")),
  CONTROL_92                = Enum (220, _("Control 92 Tremolo Depth")),
  CONTROL_93                = Enum (221, _("Control 93 Chorus Depth")),
  CONTROL_94                = Enum (222, _("Control 93 Detune Depth")),
  CONTROL_95                = Enum (223, _("Control 95 Phase Depth")),
  CONTROL_96                = Enum (224, _("Control 96 Data Increment Trigger")),
  CONTROL_97                = Enum (225, _("Control 97 Data Decrement Trigger")),
  CONTROL_98                = Enum (226, _("Control 98 Non-Registered Parameter MSB")),
  CONTROL_99                = Enum (227, _("Control 99 Non-Registered Parameter LSB")),
  CONTROL_100               = Enum (228, _("Control 100 Registered Parameter MSB")),
  CONTROL_101               = Enum (229, _("Control 101 Registered Parameter LSB")),
  CONTROL_102               = Enum (230, _("control-102")),
  CONTROL_103               = Enum (231, _("control-103")),
  CONTROL_104               = Enum (232, _("control-104")),
  CONTROL_105               = Enum (233, _("control-105")),
  CONTROL_106               = Enum (234, _("control-106")),
  CONTROL_107               = Enum (235, _("control-107")),
  CONTROL_108               = Enum (236, _("control-108")),
  CONTROL_109               = Enum (237, _("control-109")),
  CONTROL_110               = Enum (238, _("control-110")),
  CONTROL_111               = Enum (239, _("control-111")),
  CONTROL_112               = Enum (240, _("control-112")),
  CONTROL_113               = Enum (241, _("control-113")),
  CONTROL_114               = Enum (242, _("control-114")),
  CONTROL_115               = Enum (243, _("control-115")),
  CONTROL_116               = Enum (244, _("control-116")),
  CONTROL_117               = Enum (245, _("control-117")),
  CONTROL_118               = Enum (246, _("control-118")),
  CONTROL_119               = Enum (247, _("control-119")),
  CONTROL_120               = Enum (248, _("Control 120 All Sound Off ITrigger")),
  CONTROL_121               = Enum (249, _("Control 121 All Controllers Off ITrigger")),
  CONTROL_122               = Enum (250, _("Control 122 Local Control Switch")),
  CONTROL_123               = Enum (251, _("Control 123 All Notes Off ITrigger")),
  CONTROL_124               = Enum (252, _("Control 124 Omni Mode Off ITrigger")),
  CONTROL_125               = Enum (253, _("Control 125 Omni Mode On ITrigger")),
  CONTROL_126               = Enum (254, _("Control 126 Monophonic Voices Mode")),
  CONTROL_127               = Enum (255, _("Control 127 Polyphonic Mode On ITrigger")),
};

enum MidiControl {
  // special cased signals
  NONE                  = Enum (0, _("None")),
  // 14bit, continuous controls
  CONTINUOUS_0          = Enum (64,  _("Bank Select"), _("Continuous MIDI Control #1 - Bank Select")),
  CONTINUOUS_1          = Enum (65,  _("Modulation Depth")),
  CONTINUOUS_2          = Enum (66,  _("Breath Control")),
  CONTINUOUS_3          = Enum (67,  _("Continuous 3")),
  CONTINUOUS_4          = Enum (68,  _("Foot Controller")),
  CONTINUOUS_5          = Enum (69,  _("Portamento Time")),
  CONTINUOUS_6          = Enum (70,  _("Data Entry")),
  CONTINUOUS_7          = Enum (71,  _("Volume")),
  CONTINUOUS_8          = Enum (72,  _("Balance")),
  CONTINUOUS_9          = Enum (73,  _("Continuous 9")),
  CONTINUOUS_10         = Enum (74,  _("Panorama")),
  CONTINUOUS_11         = Enum (75,  _("Expression")),
  CONTINUOUS_12         = Enum (76,  _("Effect Control 1")),
  CONTINUOUS_13         = Enum (77,  _("Effect Control 2")),
  CONTINUOUS_14         = Enum (78,  _("Continuous 14")),
  CONTINUOUS_15         = Enum (79,  _("Continuous 15")),
  CONTINUOUS_16         = Enum (80,  _("General Purpose Controller 1")),
  CONTINUOUS_17         = Enum (81,  _("General Purpose Controller 2")),
  CONTINUOUS_18         = Enum (82,  _("General Purpose Controller 3")),
  CONTINUOUS_19         = Enum (83,  _("General Purpose Controller 4")),
  CONTINUOUS_20         = Enum (84,  _("Continuous 20")),
  CONTINUOUS_21         = Enum (85,  _("Continuous 21")),
  CONTINUOUS_22         = Enum (86,  _("Continuous 22")),
  CONTINUOUS_23         = Enum (87,  _("Continuous 23")),
  CONTINUOUS_24         = Enum (88,  _("Continuous 24")),
  CONTINUOUS_25         = Enum (89,  _("Continuous 25")),
  CONTINUOUS_26         = Enum (90,  _("Continuous 26")),
  CONTINUOUS_27         = Enum (91,  _("Continuous 27")),
  CONTINUOUS_28         = Enum (92,  _("Continuous 28")),
  CONTINUOUS_29         = Enum (93,  _("Continuous 29")),
  CONTINUOUS_30         = Enum (94,  _("Continuous 30")),
  CONTINUOUS_31         = Enum (95,  _("Continuous 31")),
  // 7bit, literal channel controls, MSB values
  CONTROL_0             = Enum (128, _("Control 0 Bank Select MSB")),
  CONTROL_1             = Enum (129, _("Control 1 Modulation Depth MSB")),
  CONTROL_2             = Enum (130, _("Control 2 Breath Control MSB")),
  CONTROL_3             = Enum (131, _("control-3")),
  CONTROL_4             = Enum (132, _("Control 4 Foot Controller MSB")),
  CONTROL_5             = Enum (133, _("Control 5 Portamento Time MSB")),
  CONTROL_6             = Enum (134, _("Control 6 Data Entry MSB")),
  CONTROL_7             = Enum (135, _("Control 7 Volume MSB")),
  CONTROL_8             = Enum (136, _("Control 8 Balance MSB")),
  CONTROL_9             = Enum (137, _("control-9")),
  CONTROL_10            = Enum (138, _("Control 10 Panorama MSB")),
  CONTROL_11            = Enum (139, _("Control 11 Expression MSB")),
  CONTROL_12            = Enum (140, _("Control 12 Effect Control 1 MSB")),
  CONTROL_13            = Enum (141, _("Control 13 Effect Control 2 MSB")),
  CONTROL_14            = Enum (142, _("control-14")),
  CONTROL_15            = Enum (143, _("control-15")),
  CONTROL_16            = Enum (144, _("Control 16 General Purpose Controller 1 MSB")),
  CONTROL_17            = Enum (145, _("Control 17 General Purpose Controller 2 MSB")),
  CONTROL_18            = Enum (146, _("Control 18 General Purpose Controller 3 MSB")),
  CONTROL_19            = Enum (147, _("Control 19 General Purpose Controller 4 MSB")),
  CONTROL_20            = Enum (148, _("control-20")),
  CONTROL_21            = Enum (149, _("control-21")),
  CONTROL_22            = Enum (150, _("control-22")),
  CONTROL_23            = Enum (151, _("control-23")),
  CONTROL_24            = Enum (152, _("control-24")),
  CONTROL_25            = Enum (153, _("control-25")),
  CONTROL_26            = Enum (154, _("control-26")),
  CONTROL_27            = Enum (155, _("control-27")),
  CONTROL_28            = Enum (156, _("control-28")),
  CONTROL_29            = Enum (157, _("control-29")),
  CONTROL_30            = Enum (158, _("control-30")),
  CONTROL_31            = Enum (159, _("control-31")),
  // 7bit, literal channel controls, LSB values
  CONTROL_32            = Enum (160, _("Control 32 Bank Select LSB")),
  CONTROL_33            = Enum (161, _("Control 33 Modulation Depth LSB")),
  CONTROL_34            = Enum (162, _("Control 34 Breath Control LSB")),
  CONTROL_35            = Enum (163, _("control-35")),
  CONTROL_36            = Enum (164, _("Control 36 Foot Controller LSB")),
  CONTROL_37            = Enum (165, _("Control 37 Portamento Time LSB")),
  CONTROL_38            = Enum (166, _("Control 38 Data Entry LSB")),
  CONTROL_39            = Enum (167, _("Control 39 Volume LSB")),
  CONTROL_40            = Enum (168, _("Control 40 Balance LSB")),
  CONTROL_41            = Enum (169, _("control-41")),
  CONTROL_42            = Enum (170, _("Control 42 Panorama LSB")),
  CONTROL_43            = Enum (171, _("Control 43 Expression LSB")),
  CONTROL_44            = Enum (172, _("Control 44 Effect Control 1 LSB")),
  CONTROL_45            = Enum (173, _("Control 45 Effect Control 2 LSB")),
  CONTROL_46            = Enum (174, _("control-46")),
  CONTROL_47            = Enum (175, _("control-47")),
  CONTROL_48            = Enum (176, _("Control 48 General Purpose Controller 1 LSB")),
  CONTROL_49            = Enum (177, _("Control 49 General Purpose Controller 2 LSB")),
  CONTROL_50            = Enum (178, _("Control 50 General Purpose Controller 3 LSB")),
  CONTROL_51            = Enum (179, _("Control 51 General Purpose Controller 4 LSB")),
  CONTROL_52            = Enum (180, _("control-52")),
  CONTROL_53            = Enum (181, _("control-53")),
  CONTROL_54            = Enum (182, _("control-54")),
  CONTROL_55            = Enum (183, _("control-55")),
  CONTROL_56            = Enum (184, _("control-56")),
  CONTROL_57            = Enum (185, _("control-57")),
  CONTROL_58            = Enum (186, _("control-58")),
  CONTROL_59            = Enum (187, _("control-59")),
  CONTROL_60            = Enum (188, _("control-60")),
  CONTROL_61            = Enum (189, _("control-61")),
  CONTROL_62            = Enum (190, _("control-62")),
  CONTROL_63            = Enum (191, _("control-63")),
  // 7bit, literal channel controls
  CONTROL_64            = Enum (192, _("Control 64 Damper Pedal Switch (Sustain)")),
  CONTROL_65            = Enum (193, _("Control 65 Portamento Switch")),
  CONTROL_66            = Enum (194, _("Control 66 Sustenuto Switch")),
  CONTROL_67            = Enum (195, _("Control 67 Soft Switch")),
  CONTROL_68            = Enum (196, _("Control 68 Legato Pedal Switch")),
  CONTROL_69            = Enum (197, _("Control 69 Hold Pedal Switch")),
  CONTROL_70            = Enum (198, _("Control 70 Sound Variation")),
  CONTROL_71            = Enum (199, _("Control 71 Filter Resonance (Timbre)")),
  CONTROL_72            = Enum (200, _("Control 72 Sound Release Time")),
  CONTROL_73            = Enum (201, _("Control 73 Sound Attack Time")),
  CONTROL_74            = Enum (202, _("Control 74 Sound Brightness")),
  CONTROL_75            = Enum (203, _("Control 75 Sound Decay Time")),
  CONTROL_76            = Enum (204, _("Control 76 Vibrato Rate")),
  CONTROL_77            = Enum (205, _("Control 77 Vibrato Depth")),
  CONTROL_78            = Enum (206, _("Control 78 Vibrato Delay")),
  CONTROL_79            = Enum (207, _("Control 79 Sound Control 10")),
  CONTROL_80            = Enum (208, _("Control 80 General Purpose Switch 5")),
  CONTROL_81            = Enum (209, _("Control 81 General Purpose Switch 6")),
  CONTROL_82            = Enum (210, _("Control 82 General Purpose Switch 7")),
  CONTROL_83            = Enum (211, _("Control 83 General Purpose Switch 8")),
  CONTROL_84            = Enum (212, _("Control 84 Portamento Control (Note)")),
  CONTROL_85            = Enum (213, _("control-85")),
  CONTROL_86            = Enum (214, _("control-86")),
  CONTROL_87            = Enum (215, _("control-87")),
  CONTROL_88            = Enum (216, _("control-88")),
  CONTROL_89            = Enum (217, _("control-89")),
  CONTROL_90            = Enum (218, _("control-90")),
  CONTROL_91            = Enum (219, _("Control 91 Reverb Depth")),
  CONTROL_92            = Enum (220, _("Control 92 Tremolo Depth")),
  CONTROL_93            = Enum (221, _("Control 93 Chorus Depth")),
  CONTROL_94            = Enum (222, _("Control 93 Detune Depth")),
  CONTROL_95            = Enum (223, _("Control 95 Phase Depth")),
  CONTROL_96            = Enum (224, _("Control 96 Data Increment Trigger")),
  CONTROL_97            = Enum (225, _("Control 97 Data Decrement Trigger")),
  CONTROL_98            = Enum (226, _("Control 98 Non-Registered Parameter MSB")),
  CONTROL_99            = Enum (227, _("Control 99 Non-Registered Parameter LSB")),
  CONTROL_100           = Enum (228, _("Control 100 Registered Parameter MSB")),
  CONTROL_101           = Enum (229, _("Control 101 Registered Parameter LSB")),
  CONTROL_102           = Enum (230, _("control-102")),
  CONTROL_103           = Enum (231, _("control-103")),
  CONTROL_104           = Enum (232, _("control-104")),
  CONTROL_105           = Enum (233, _("control-105")),
  CONTROL_106           = Enum (234, _("control-106")),
  CONTROL_107           = Enum (235, _("control-107")),
  CONTROL_108           = Enum (236, _("control-108")),
  CONTROL_109           = Enum (237, _("control-109")),
  CONTROL_110           = Enum (238, _("control-110")),
  CONTROL_111           = Enum (239, _("control-111")),
  CONTROL_112           = Enum (240, _("control-112")),
  CONTROL_113           = Enum (241, _("control-113")),
  CONTROL_114           = Enum (242, _("control-114")),
  CONTROL_115           = Enum (243, _("control-115")),
  CONTROL_116           = Enum (244, _("control-116")),
  CONTROL_117           = Enum (245, _("control-117")),
  CONTROL_118           = Enum (246, _("control-118")),
  CONTROL_119           = Enum (247, _("control-119")),
  CONTROL_120           = Enum (248, _("Control 120 All Sound Off ITrigger")),
  CONTROL_121           = Enum (249, _("Control 121 All Controllers Off ITrigger")),
  CONTROL_122           = Enum (250, _("Control 122 Local Control Switch")),
  CONTROL_123           = Enum (251, _("Control 123 All Notes Off ITrigger")),
  CONTROL_124           = Enum (252, _("Control 124 Omni Mode Off ITrigger")),
  CONTROL_125           = Enum (253, _("Control 125 Omni Mode On ITrigger")),
  CONTROL_126           = Enum (254, _("Control 126 Monophonic Voices Mode")),
  CONTROL_127           = Enum (255, _("Control 127 Polyphonic Mode On ITrigger")),
};

// For musical tunings, see: http://en.wikipedia.org/wiki/Musical_tuning
enum MusicalTuning {
  // Equal Temperament: http://en.wikipedia.org/wiki/Equal_temperament
  OD_12_TET          = Enum (1, _("12 Tone Equal Temperament"),   // http://en.wikipedia.org/wiki/Equal_temperament
                             _("The most common tuning system for modern Western music, "
                               "is the twelve-tone equal temperament, abbreviated as 12-TET, "
                               "which divides the octave into 12 equal parts.")),
  OD_7_TET           = Enum (_("7 Tone Equal Temperament"),      // http://en.wikipedia.org/wiki/Equal_temperament
                             _("A fairly common tuning system is the seven-tone equal temperament tuning system, "
                               "abbreviated as 7-TET. It divides the octave into 7 equal parts using 171 cent steps.")),
  OD_5_TET           = Enum (_("5 Tone Equal Temperament"),      // http://en.wikipedia.org/wiki/Equal_temperament
                             _("A fairly common tuning system is the five-tone equal temperament tuning system, "
                               "abbreviated as 5-TET. It divides the octave into 5 equal parts using 240 cent steps.")),
  // Rational Intonation: http://en.wikipedia.org/wiki/Just_intonation
  DIATONIC_SCALE     = Enum (_("Diatonic Scale"),                 // http://en.wikipedia.org/wiki/Diatonic_scale
                             _("In music theory, a diatonic scale (also: heptatonia prima) is a seven-note "
                               "musical scale comprising five whole-tone and two half-tone steps. "
                               "The half tones are maximally separated, so between two half-tone steps "
                               "there are either two or three whole tones, repeating per octave.")), // Werckmeister I
  INDIAN_SCALE       = Enum (_("Indian Scale"),                   // http://en.wikipedia.org/wiki/Just_intonation#Indian_scales
                             _("Diatonic scale used in Indian music with wolf interval at Dha, close to 3/2")),
  PYTHAGOREAN_TUNING = Enum (_("Pythagorean Tuning"),             // http://en.wikipedia.org/wiki/Pythagorean_tuning
                             _("Pythagorean tuning is the oldest way of tuning the 12-note chromatic scale, "
                               "in which the frequency relationships of all intervals are based on the ratio 3:2. "
                               "Its discovery is generally credited to Pythagoras.")),
  PENTATONIC_5_LIMIT = Enum (_("Pentatonic 5-limit"),             // http://en.wikipedia.org/wiki/Pentatonic_scale
                             _("Pentatonic scales are used in modern jazz and pop/rock contexts "
                               "because they work exceedingly well over several chords diatonic "
                               "to the same key, often better than the parent scale.")),
  PENTATONIC_BLUES   = Enum (_("Pentatonic Blues"),               // http://en.wikipedia.org/wiki/Pentatonic_scale
                             _("The blues scale is the minor pentatonic with an additional augmented fourth, "
                               "which is referred to as the \"blues note\".")),
  PENTATONIC_GOGO    = Enum (_("Pentatonic Gogo"),                // http://en.wikipedia.org/wiki/Pentatonic_scale
                             _("The Pentatonic Gogo scale is an anhemitonic pentatonic scale used to tune the "
                               "instruments of the Gogo people of Tanzania.")),
  // Meantone Temperament: http://en.wikipedia.org/wiki/Meantone_temperament
  QUARTER_COMMA_MEANTONE = Enum (_("Quarter-Comma Meantone"),         // http://en.wikipedia.org/wiki/Quarter-comma_meantone
                                 _("Quarter-comma meantone was the most common meantone temperament in the "
                                   "sixteenth and seventeenth centuries and sometimes used later.")), // Werckmeister II
  SILBERMANN_SORGE   = Enum (_("Silbermann-Sorge Temperament"),   // http://de.wikipedia.org/wiki/Silbermann-Sorge-Temperatur
                             _("The Silbermann-Sorge temperament is a meantone temperament used for "
                               "Baroque era organs by Gottfried Silbermann.")),
  // Well Temperament: http://en.wikipedia.org/wiki/Well_temperament
  WERCKMEISTER_3     = Enum (_("Werckmeister III"),               // http://en.wikipedia.org/wiki/Werckmeister_temperament
                             _("This tuning uses mostly pure (perfect) fifths, as in Pythagorean tuning, but each "
                               "of the fifths C-G, G-D, D-A and B-F# is made smaller, i.e. tempered by 1/4 comma. "
                               "Werckmeister designated this tuning as particularly suited for playing chromatic music.")),
  WERCKMEISTER_4     = Enum (_("Werckmeister IV"),                // http://en.wikipedia.org/wiki/Werckmeister_temperament
                             _("In this tuning the fifths C-G, D-A, E-B, F#-C#, and Bb-F are tempered narrow by 1/3 comma, "
                               "and the fifths G#-D# and Eb-Bb are widened by 1/3 comma. The other fifths are pure. "
                               "Most of its intervals are close to sixth-comma meantone. "
                               "Werckmeister designed this tuning for playing mainly diatonic music.")),
  WERCKMEISTER_5     = Enum (_("Werckmeister V"),                 // http://en.wikipedia.org/wiki/Werckmeister_temperament
                             _("In this tuning the fifths D-A, A-E, F#-C#, C#-G#, and F-C are narrowed by 1/4 comma, "
                               "and the fifth G#-D# is widened by 1/4 comma. The other fifths are pure. "
                               "This temperament is closer to equal temperament than Werckmeister III or IV.")),
  WERCKMEISTER_6     = Enum (_("Werckmeister VI"),                // http://en.wikipedia.org/wiki/Werckmeister_temperament
                             _("This tuning is also known as Septenarius tuning is based on a division of the monochord "
                               "length into 196 = 7 * 7 * 4 parts. "
                               "The resulting scale has rational frequency relationships, but in practice involves pure "
                               "and impure sounding fifths. "
                               "Werckmeister described the Septenarius as a \"temperament which has nothing at all to do "
                               "with the divisions of the comma, nevertheless in practice so correct that one can be really "
                               "satisfied with it\".")),
  KIRNBERGER_3       = Enum (_("Kirnberger III"),                 // http://en.wikipedia.org/wiki/Johann_Philipp_Kirnberger_temperament
                             _("Kirnberger's method of compensating for and closing the circle of fifths is to split the \"wolf\" "
                               "interval known to those who have used meantone temperaments between four fifths instead, "
                               "allowing for four 1/4-comma wolves to take their place. "
                               "1/4-comma wolves are used extensively in meantone and are much easier to tune and to listen to. "
                               "Therefore, only one third remains pure (between C and E).")),
  YOUNG              = Enum (_("Young Temperament"),              // http://en.wikipedia.org/wiki/Young_temperament
                             _("Thomas Young devised a form of musical tuning to make the harmony most perfect in those keys which "
                               "are the most frequently used (give better major thirds in those keys), but to not have any unplayable keys. "
                               "This is attempted by tuning upwards from C a sequence of six pure fourths, "
                               "as well as six equally imperfect fifths.")),
};

/// Offsets for signal monitoring fields in bytes, field type and size is used as prefix.
enum MonitorField {
  F64_GENERATION        =       0 * 4,  ///< Generation counter, updated on every modification.
  /* F64_GENERATION     also:   1 * 4, */
  F32_MIN               =       2 * 4,  ///< Minimum value of the last frame.
  F32_MAX               =       3 * 4,  ///< Maximum value of the last frame.
  F32_DB_SPL            =       4 * 4,  ///< Sound pressure level in dB SPL of the last frame.
  F32_DB_TIP            =       5 * 4,  ///< Maximum recent dB SPL.
  END_BYTE              =       6 * 4,  ///< Total length of all MonitorField values in bytes.
};

// == Bse Constants ==
Const MIN_NOTE        = 0;
Const MAX_NOTE        = 131;          // 123
Const NOTE_VOID       = MAX_NOTE + 1; /// Value represents unparsable/unknown notes
Const KAMMER_NOTE     = 69;           /// Kammer note, representing the kammer frequency's MIDI note value for A' or A4
Const KAMMER_FREQ     = 440.0;        /// Pitch Standard, see also: https://en.wikipedia.org/wiki/A440_(pitch_standard)
Const KAMMER_OCTAVE   = +1;           /// Octave number for MIDI A'
Const MIN_OCTAVE      = -4;           /// Octave of MIN_NOTE
Const MAX_OCTAVE      = +6;           /// Octave of MAX_NOTE
Const MIN_FINE_TUNE   = -100;
Const MAX_FINE_TUNE   = 100;
Const MIN_BPM         = 1;
Const MAX_BPM         = 1024;
Const MIN_TRANSPOSE   = -72;
Const MAX_TRANSPOSE   = +72;
Const READWRITE       = "r:w:";
Const GUI             = "r:w:G";
Const STORAGE         = "r:w:S";
Const STANDARD        = STORAGE ":G";
Const STANDARD_RDONLY = STANDARD ":ro:";
Const NOTEHINTS       = STANDARD ":note";
Const FINETUNEHINTS   = STANDARD ":finetune";
Const VELOCITYHINTS   = STANDARD ":velocity";
Const MIN_VOLUME_DB   = -144;
Const MAX_VOLUME_DB   = 24;
Const BUS_VOLUME_MIN  = 1.58489319246111e-05; /* -96dB */
Const BUS_VOLUME_MAX  = 15.8489319246111;     /* +24dB */
Const BUS_VOLUME_DEF  = 1;
Const BUS_VOLUME_STEP = 0.1;
Const MAX_MIDI_CHANNEL = 99;
/* extra options */
Const SKIP_DEFAULT    = ":skip-default:";
Const SKIP_UNDO       = ":skip-undo:";

/// Stringeq - a variable length list of test strings.
sequence StringSeq {
  String string;
};

/// Representation of an image pixel sequence in ARGB format.
sequence PixelSeq {
  int32 argb = Num ("ARGB", "ARGB Format: (alpha << 24) | (red << 16) | (green << 8) | blue", STANDARD);
};

/// Representation of an icon pixel image.
record Icon {
  int32    width  = Range    ("Width",  "Width in pixels or 0 for no icon",  STANDARD, 0, 4096, 1, 0);
  int32    height = Range    ("Height", "Height in pixels or 0 for no icon", STANDARD, 0, 4096, 1, 0);
  PixelSeq pixels = Sequence ("Pixels", "Array of width*height ARGB pixels", STANDARD);
};

/// AuxData - record to describe entity attributes with "key=value" strings.
record AuxData {
  String    entity;             ///< Entity that has an auxillary data list.
  StringSeq attributes;         ///< List of "key=value" auxillary data strings.
};

/// AuxDataSeq - a variable length list of AuxData records.
sequence AuxDataSeq {
  AuxData aux_data;
};

enum UserMessageType {
  ERROR = 1,    ///< Indicate a message about an error condition.
  WARNING,      ///< Indicate a message about a possibly harmful condition.
  INFO,         ///< Indicate an informational message.
  DEBUG,        ///< Indicate a debugging message (usually insignificant).
};

/// Structure for submission of user interface messages from BSE.
record UserMessage {
  UserMessageType utype;        ///< Severity classification for this message.
  String          title;        ///< Usually GUI window title.
  String          text1;        ///< Primary message to the user, should be limited to 80-100 chars.
  String          text2;        ///< Explanatory (secondary) message no limitations recommended.
  String          text3;        ///< Possibly (technical) details or machine error message.
  String          label;        ///< Message class label, used to enable/disable this type of message.
};

/// Song timing configuration.
record SongTiming {
  int32   tick        = Range ("Current tick", "Song position timing applies to", STANDARD, 0, MAXINT31, 384, 0);
  float64 bpm         = Range ("BPM", "Beats per minute", STANDARD, MIN_BPM, MAX_BPM, 10, 120);
  // Signature
  int32   numerator   = Range ("Numerator", "Number of notes per measure", STANDARD, 1, 256, 2, 4);
  int32   denominator = Range ("Denominator", "Type of notes counted per measure", STANDARD, 1, 256, 2, 4);
  // Sequencer Timing
  int32   tpqn        = Range ("TPQN", "Ticks per quarter note", STANDARD, 1, MAXINT31, 12, 384);
  int32   tpt         = Range ("TPT", "Ticks per tact", STANDARD, 1, MAXINT31, 12, 384);
  // Playback Timing
  float64 stamp_ticks = Range ("Tick Increment", "Ticks per stamp increment (useful only during playback)", STANDARD, 1, MAXINT31, 12, 384);
};

/// A note description provides all needed details about a specific note. "
record NoteDescription
{
  MusicalTuning musical_tuning;
  int32    note            = Range ("Note", "", ":readwrite:note");
  int32    octave          = Range ("Octave", "", ":readwrite:octave");
  float64  freq            = Range ("Frequency", "", ":readwrite:freq");
  int32    finetune        = Range ("Finetune", "", ":readwrite:finetune", -100, +100, 10, 0);
  int32    semitone        = Range ("Semitone", "", ":readwrite", 0, 11, 1, 0);
  bool     upshift         = Bool ("Upshift", "Flag set for notes that correspond to a black piano key");
  int32    letter          = Range ("Letter", "International abbreviation letter for this note", ":readwrite", 32, 126, 1, 64);
  String   name            = String ("Name", "", ":readwrite");
};

// Forward declarations.
record PartLink;
sequence PartLinkSeq;
record TrackPart;
sequence TrackPartSeq;
interface Item;
interface Source;
interface WaveOsc;
interface Project;

/// Base type for all new style C++ objects.
interface Object {
  // dynamic properties
  bool      set_prop   (String name, Any value); ///< Set dynamic property `name` to `value`.
  Any       get_prop   (String name);            ///< Get value of dynamic property `name`.
  StringSeq find_prop  (String name);            ///< Query `key=value` meta info for dynamic property `name`.
  StringSeq list_props ();                       ///< List names of all dynamic properties.
  void      notify     (String detail);          ///< Emit notification event for object state or property changes.
};

/** Base type for all legacy objects, derived from `struct BseObject`.
 *
 * ### Events:
 * - **notify** - A notification event for property changes, the event field *detail* contains the property name.
 */
interface LegacyObject : Object {
  String        uname           = String ("UName", "Unique object name", GUI);
  String        debug_name      ();                     ///< Object name useful for debugging output.
  int32         unique_id       ();                     ///< Generate a unique stable ID for this object, similar to a hash of its address.
  int64         proxy_id        ();                     ///< Helper ID for the old SfiGlue interface.
  StringSeq     find_typedata   (String type_name);             ///< Query `key=value` meta info for type `type_name`.
};

/// A list of Item or derived objects.
sequence ItemSeq {
  Item items;
};

/// A list of items suitable to set as a specific property value.
record PropertyCandidates {
  Info      blurb      = ("A structure describing tentative property values.");
  String    label;
  String    tooltip;
  ItemSeq   items;
  // List of types which may logically partition the list of items by type discrimination
  StringSeq partitions;
};

/// Base interface type for objects that can be added to a container.
interface Item : LegacyObject {
  Icon    icon = Record ("Icon", "State dependent icon representation of this item", "rw:G");
  Item    use               (); ///< Increment use count to keep an item alive.
  void    unuse             (); ///< Decrement use count for when an item is not needed anymore.
  void    set_name          (String name);       ///< Assign an item's name.
  Item    common_ancestor   (Item other);        ///< Find a common container (parent or grand-parent) of two items if any.
  bool    check_is_a        (String type_name);  ///< Check whether an item has a certain type.
  void    group_undo        (String group_name); ///< Request multiple modifying actions on an item to be grouped together as a single undo operation.
  void    ungroup_undo      (); ///< Ends the undo grouping opened up by a previous group-undo() call.
  Project get_project       (); ///< Retrieve an item's project.
  Item    get_parent        (); ///< Retrieve an item's parent.
  int32   get_seqid         (); ///< Retrieve an item's sequential ID. The sequential ID depends on the item's type an it's position inbetween siblings of the same type within it's immediate container.
  String  get_type          (); ///< Retrieve an item's type name.
  String  get_type_authors  (); ///< Retrieve authors of an item's type implementation.
  String  get_type_blurb    (); ///< Retrieve an item's type description.
  String  get_type_license  (); ///< Retrieve the license for an item's type implementation.
  String  get_type_name     (); ///< Retrieve an item's type name.
  String  get_uname_path    (); ///< Retrieve the project relative uname path for this item.
  String  get_name          (); ///< Retrieve an item's name.
  String  get_name_or_type  (); ///< Retrieve an item's name or type if it has no name.
  bool    internal          (); ///< Check whether an item is internal, i.e. owned by another non-internal item.
  bool    editable_property (String property); ///< Test whether a property is editable according to object state and property options.
  PropertyCandidates get_property_candidates (String property_name); ///< Retrieve tentative values for an item or item sequence property.

  int32   seqid = Range ("Sequential ID", "", "r", 0, MAXINT31, 1, 0);
};

/// Part specific note event representation.
record PartNote
{
  int32   id        = Num ("ID", "", 0, ":readwrite");
  int32   channel   = Range ("Channel", "", ":readwrite", 0, MAXINT31, 1);
  int32   tick      = Range ("Tick", "", ":readwrite", 0, MAXINT31, 1);
  int32   duration  = Range ("Duration", "Duration in number of ticks", ":readwrite", 0, MAXINT31, 1);
  int32   note      = Range ("Note", "", NOTEHINTS, MIN_NOTE, MAX_NOTE, 12, KAMMER_NOTE);
  int32   fine_tune = Range ("Fine Tune", "", FINETUNEHINTS, MIN_FINE_TUNE, MAX_FINE_TUNE, 1);
  float64 velocity  = Range ("Velocity", "", VELOCITYHINTS, 0, 1.0, 0.1, 1);
  bool    selected  = Bool ("Selected", "", ":readwrite", false);
};

/// A list of part note events.
sequence PartNoteSeq {
  PartNote part_notes;
};

/// Part specific control event representation.
record PartControl {
  int32          id           = Num ("ID", "", ":readwrite");
  int32          tick         = Range ("Tick", "", ":readwrite", 0, MAXINT31, 1);
  MidiSignal     control_type;
  float64        value        = Range ("Value", "", ":readwrite", -1, +1, 0.1);
  bool           selected     = Bool ("Selected", "", ":readwrite");
};

/// A list of part control events.
sequence PartControlSeq {
  PartControl pcontrols;
};

/// Data interface for containment of piano notes and MIDI effects.
interface Part : Item {
  PartControlSeq list_selected_controls    (MidiSignal control_type); ///< List all currently selected control events of a specific type.
  PartControlSeq list_controls             (int32 tick, int32 duration, MidiSignal control_type); ///< List all control events within a tick range.
  PartControlSeq get_channel_controls      (int32 channel, int32 tick, int32 duration, MidiSignal control_type); ///< Retrieve all control events of a specific type within range of a channel.
  PartControlSeq get_controls              (int32 tick, MidiSignal control_type); ///< Retrieve all control events of a specific type at specified tick.
  SongTiming     get_timing                (int32 tick); ///< Retrieve song timing information at a specific tick.
  int32          get_max_note              ();           ///< Retrieve the maximum note supported in this part.
  int32          get_min_note              ();           ///< Retrieve the minimum note supported in this part.
  int32          get_last_tick             ();           ///< Retrieve the maximum tick any control or note plus duration spans.
  Error          change_control            (int32 id, int32 tick, MidiSignal control_type, float64 value); ///< Change an existing control event within a part.
  Error          change_note               (int32 id, int32 tick, int32 duration, int32 note, int32 fine_tune, float64 velocity); ///< Change an existing note within a part.
  Error          delete_event              (int32 id); ///< Delete an existing event from a part.
  int32          insert_control            (int32 tick, MidiSignal control_type, float64 value); ///< Insert a new control event into a part.
  int32          insert_note               (int32 channel, int32 tick, int32 duration, int32 note, int32 fine_tune, float64 velocity); ///< Insert a new note into a part.
  int32          insert_note_auto          (int32 tick, int32 duration, int32 note, int32 fine_tune, float64 velocity); ///< Insert a new note into a part with automatic channel selection.
  bool           is_event_selected         (int32 id); ///< Check whether an event is selected.
  void           queue_controls            (int32 tick, int32 duration); ///< Queue updates for all control events and notes starting within the given range.
  void           queue_notes               (int32 tick, int32 duration, int32 min_note, int32 max_note); ///< Queue updates for all notes starting within the given rectangle.
  void           select_notes_exclusive    (int32 tick, int32 duration, int32 min_note, int32 max_note); ///< Select all notes within rectangle and deselect all others.
  void           select_controls_exclusive (int32 tick, int32 duration, MidiSignal control_type); ///< Select all control events within range and deselect all others.
  void           select_notes              (int32 tick, int32 duration, int32 min_note, int32 max_note); ///< Select all notes within rectangle.
  void           select_event              (int32 id); ///< Select an existing event.
  void           select_controls           (int32 tick, int32 duration, MidiSignal control_type); ///< Select all control events within range.
  void           deselect_notes            (int32 tick, int32 duration, int32 min_note, int32 max_note); ///< Deselect all notes within rectangle.
  void           deselect_event            (int32 id); ///< Deselect an existing event.
  void           deselect_controls         (int32 tick, int32 duration, MidiSignal control_type); ///< Deselect all controls within given range.
  PartNoteSeq list_notes_crossing (int32 tick, int32 duration); ///< List all notes within or crossing a tick range.
  PartNoteSeq list_notes_within   (int32 channel, int32 tick, int32 duration); ///< List all notes within a tick range.
  PartNoteSeq list_selected_notes (); ///< List all currently selected notes.
  PartNoteSeq check_overlap       (int32 tick, int32 duration, int32 note); ///< Check whether a note would overlap with neighbours.
  PartNoteSeq get_notes           (int32 tick, int32 note); ///< Retrieve all notes at a specific frequency or crossing a tick.
  PartLinkSeq list_links          (); ///< List all places where parts are used (linked) from tracks, sorted by tick.

  // signal void    range_changed             (int32 a, int32 b, int32 c, int32 d);
  // signal void    links_changed             ();
  // property int32 n_channels;
  group "Limits" {
    int32 last_tick  = Range ("Last Tick", "", ":r:G", 0, MAXINT31, 384, 0);
    int32 n_channels = Range ("Channels", "", STANDARD, 1, 1024, 4, 1);
  };
};

/// A list of Part or derived types.
sequence PartSeq {
  Part part;
};

/// A list of floating point values.
sequence FloatSeq {
  float64 floats;
};

/// Descriptor for a shared memory region.
record SharedMemory {
  int64  shm_creator;   ///< IPC id of the shared memory creator process.
  int64  shm_start;     ///< Shared memory area location.
  int64  shm_length;    ///< Shared memory area length in bytes
};

/// Bits representing a selection of probe sample data features.
record ProbeFeatures {
  bool          probe_range;
  bool          probe_energy;
  bool          probe_samples;
  bool          probe_fft;
};

/// Interface for monitoring output signals.
interface SignalMonitor : Object {
  Source        get_osource        ();                  ///< Retrieve output module the SignalMonitor is connected to.
  int32         get_ochannel       ();                  ///< Retrieve output channel the SignalMonitor is connected to.
  int64         get_mix_freq       ();                  ///< Mix frequency at which monitor values are calculated.
  int64         get_frame_duration ();                  ///< Frame duration in seconds for the calculation of monitor values.
  int64         get_shm_offset     (MonitorField fld);  ///< Offset into shared memory for MonitorField values of `ochannel`.
  void          set_probe_features (ProbeFeatures pf);  ///< Configure probe features.
  ProbeFeatures get_probe_features ();                  ///< Get configured probe features.
};

/// Base interface type for synthesis modules with input or output streams.
interface Source : Item {
  Source ichannel_get_osource (int32 input_channel, int32 input_joint); ///< Retrieve output module connected to a specific joint of an input channel.

  void clear_inputs ();  ///< Disconnect all module inputs.
  void clear_outputs (); ///< Disconnect all module outputs.
  bool has_output (int32 ochannel); ///< Check whether a module's output channel is connected.
  bool has_outputs (); ///< Check whether a module has output channel connections.
  String ichannel_blurb (int32 input_channel); ///< Get input channel description.
  int32 ichannel_get_n_joints (int32 input_channel); ///< Retrieve the number of inputs connected to an input channel.
  int32 ichannel_get_ochannel (int32 input_channel, int32 input_joint); ///< Retrieve output channel of the module connected to a specific joint of an input channel.
  String ichannel_ident (int32 input_channel); ///< Get canonical input channel name.
  String ichannel_label (int32 input_channel); ///< Get input channel name.
  bool is_joint_ichannel (String input_channel); ///< Check if an input channel is a joint (multi-connect) channel.
  bool is_joint_ichannel_by_id (int32 input_channel); ///< Check if an input channel is a joint (multi-connect) channel.
  bool is_prepared (); ///< Check whether a source is prepared for synthesis processing.
  int32 n_ichannels (); ///< Get the number of input channels of a module.
  int32 n_ochannels (); ///< Get the number of output channels of a module.
  String ochannel_blurb (int32 output_channel); ///< Get output channel description.
  String ochannel_ident (int32 output_channel); ///< Get canonical output channel name.
  String ochannel_label (int32 output_channel); ///< Get output channel name.

  /** Setup automation parameters for a property.
   * @param midi_channel The MIDI Channel from which automation events should be received, 0 designates the default MIDI channel
   * @param control_type The type of control events used for automation
   */
  Error       set_automation         (String property_name, int32 midi_channel, MidiControl control_type);
  MidiControl get_automation_control (String property_name); ///< Get control type from an automation property.
  int32       get_automation_channel (String property_name); ///< Get MIDI channel from an automation property.
  Error set_input (String input_channel, Source omodule, String output_channel); ///< Connect a module input to another module's output.
  Error set_input_by_id (int32 input_channel, Source omodule, int32 output_channel); ///< Connect a module input to another module's output.
  Error unset_input (String input_channel, Source omodule, String output_channel); ///< Disconnect a module input.
  Error unset_input_by_id (int32 input_channel, Source omodule, int32 output_channel); ///< Disconnect a module input.
  // signal void io_changed ();
  group "Position" {
    float64 pos_x = Range ("Position X", "", STORAGE ":skip-default:f:", -MAXFLOAT64, MAXFLOAT64, 10, 0);
    float64 pos_y = Range ("Position Y", "", STORAGE ":skip-default:f:", -MAXFLOAT64, MAXFLOAT64, 10, 0);
  };
  /** Set the x and y position of a module.
   * In contrast to setting the position through ordinary object property
   * setters, this function will not update the module position if the passed
   * in arguments are sufficiently equal to the values already set on the
   * object. As such, it does not record an extra undo step for setting
   * properties to values they already have and if necessary turns setting
   * of x and y positions into an atomic undo operation.
   */
  void set_pos (float64 x_pos, float64 y_pos);
  /// Retrieve the current mixing frequency used for probes.
  int32       get_mix_freq   ();

  /// Create signal monitor for an output channel.
  SignalMonitor create_signal_monitor (int32 ochannel);
};

/** Base interface type for containers of Item derived types.
 * ### Events:
 * - **treechange** - Detail: 'additem' or 'removeitem' - a notification event is sent when an item is added to or removed from the container.
 */
interface Container : Source {
  Item lookup_item (String uname); ///< Find an immediate child of a container by name (unique per container child).
  Item get_item    (String item_type, int32 seq_id); ///< Retrieve the immediate child of type @a item_type by its sequential id (the 'nth' child).
  ItemSeq list_children (); ///< List all immediate children of a container.
};

/// Source module for merging multiple synthesis contexts, used to implement polyphony.
interface ContextMerger : Container {
};

/// Base interface type for Item managers.
interface Super : Container {
  String author  = String (_("Author"), _("Person changing or creating this object"), STANDARD);
  String license = String (_("License"), _("Copyright license applying to this object"), STANDARD);
};

/// A list of Super type objects.
sequence SuperSeq {
  Super supers;
};

/// Base interface type for all kinds of synthesis networks.
interface SNet : Super {
  bool        supports_user_synths ();                ///< Check whether users may edit synthesis modules of this network.
  Error       can_create_source (String module_type); ///< Check whether inserting a new module into a synthesis network is possible.
  Source      create_source     (String module_type); ///< Insert a new module into a synthesis network.
  Error       remove_source     (Source module);      ///< Remove an existing module from its synthesis network.
  // signal void port_unregistered ();                   ///< Signal that notifies when a named output port is unregistered.
  group _("Playback Settings") {
    bool      auto_activate = Bool (_("Auto Activate"),
                                    _("Automatic activation only needs to be enabled for synthesis networks that don't "
                                      "use virtual ports for their input and output"),
                                    STANDARD, true);
  };
};

/// Customizable synthesis (filter) network container.
interface CSynth : SNet {
};

/// Synthesizer module for embedding (rerouting input and output) of another synthesizer network (SNet).
interface SubSynth : Source {
  // CSynth snet       = Object ("Synthesizer",   "Synthesis network to use as embedded sub network", STANDARD ":unprepared");
  // String in_port_1  = String ("Input Port 1",  "Output port name to interface from",               STANDARD ":skip-default");
  // String out_port_1 = String ("Output Port 1", "Input port name to interface to",                  STANDARD ":skip-default");
  // String in_port_2  = String ("Input Port 2",  "Output port name to interface from",               STANDARD ":skip-default");
  // String out_port_2 = String ("Output Port 2", "Input port name to interface to",                  STANDARD ":skip-default");
  // String in_port_3  = String ("Input Port 3",  "Output port name to interface from",               STANDARD ":skip-default");
  // String out_port_3 = String ("Output Port 3", "Input port name to interface to",                  STANDARD ":skip-default");
  // String in_port_4  = String ("Input Port 4",  "Output port name to interface from",               STANDARD ":skip-default");
  // String out_port_4 = String ("Output Port 4", "Input port name to interface to",                  STANDARD ":skip-default");
  // String in_port_5  = String ("Input Port 5",  "Output port name to interface from",               STANDARD ":skip-default");
  // String out_port_5 = String ("Output Port 5", "Input port name to interface to",                  STANDARD ":skip-default");
  // String in_port_6  = String ("Input Port 6",  "Output port name to interface from",               STANDARD ":skip-default");
  // String out_port_6 = String ("Output Port 6", "Input port name to interface to",                  STANDARD ":skip-default");
  // String in_port_7  = String ("Input Port 7",  "Output port name to interface from",               STANDARD ":skip-default");
  // String out_port_7 = String ("Output Port 7", "Input port name to interface to",                  STANDARD ":skip-default");
  // String in_port_8  = String ("Input Port 8",  "Output port name to interface from",               STANDARD ":skip-default");
  // String out_port_8 = String ("Output Port 8", "Input port name to interface to",                  STANDARD ":skip-default");
};

/// Info for module types.
record ModuleTypeInfo {
  String id;
  String label;
  String blurb;
  String category;
};

/// Interface for the encapsulation of audio processors.
interface Module : Object {
  // module type determination
  String         get_module_type  ();                           ///< Retrieve type of module to be created.
  ModuleTypeInfo module_type_info ();                           ///< Describe this module type.
};
sequence ModuleSeq { Module modules; };

/// Details about property choice values.
record Choice {
  String ident;         ///< Identifier used for serialization.
  String label;         ///< Preferred user interface name.
  String subject;       ///< Subject line, a brief one liner or elaborate title.
  String icon;          ///< Stringified icon, SVG and PNG should be supported (64x64 pixels recommended).
};
sequence ChoiceSeq { Choice choice; };

/// A Property allows querying, setting and monitoring of an object property.
interface Property : Object {
  String    identifier     ();          ///< Unique name (per owner) of this Property.
  String    label          ();          ///< Preferred user interface name.
  String    nick           ();          ///< Abbreviated user interface name, usually not more than 6 characters.
  String    unit           ();          ///< Units of the values within range.
  String    hints          ();          ///< Hints for parameter handling.
  String    group          ();          ///< Group name for parameters of similar function.
  String    blurb          ();          ///< Short description for user interface tooltips.
  String    description    ();          ///< Elaborate description for help dialogs.
  float64   get_min        ();          ///< Get the minimum property value, converted to float64.
  float64   get_max        ();          ///< Get the maximum property value, converted to float64.
  float64   get_step       ();          ///< Get the property value stepping, converted to float64.
  float64   get_normalized ();          ///< Get the normalized property value, converted to float64.
  bool      set_normalized (float64 v); ///< Set the normalized property value as float64.
  String    get_text       ();          ///< Get the current property value, converted to a text String.
  bool      set_text       (String v);  ///< Set the current property value as a text String.
  bool      is_numeric     ();          ///< Whether the property settings can be represented as a floating point number.
  ChoiceSeq choices        ();          ///< Enumerate choices for choosable properties.
};
sequence PropertySeq { Property property; };

/// Info for device types.
record DeviceInfo {
  String uri;          ///< Unique identifier for de-/serialization.
  String name;         ///< Preferred user interface name.
  String category;     ///< Category to allow grouping for processors of similar function.
  String description;  ///< Elaborate description for help dialogs.
  String website_url;  ///< Website of/about this Processor.
  String creator_name; ///< Name of the creator.
  String creator_url;  ///< Internet contact of the creator.
};
sequence DeviceInfoSeq { DeviceInfo info; };

/// Interface for the encapsulation of audio processors.
interface Device : Object {
  // create modules
  ModuleSeq      list_modules      ();                 ///< List modules in order of processing.
  Module         create_module     (String module_id); ///< Create a new module with `module_type`.
  ModuleTypeInfo module_type_info  (String module_id); ///< Describe `module_type`.
  StringSeq      list_module_types ();                 ///< List known module types.

  // device type determination
  String         device_uri        ();                  ///< Retrieve unique identifier for the device type.
  DeviceInfo     device_info       ();                  ///< Describe this device type.
  // Device Parameters
  StringSeq      list_properties   ();                  ///< List all property identifiers.
  Property       access_property   (String ident);      ///< Retrieve handle for a Property.
  PropertySeq    access_properties (String hints);      ///< Retrieve handles for properties with specific hints.
};
sequence DeviceSeq { Device devices; };

/// Interface for the management of multiple sub devices.
interface DeviceContainer : Device {
  DeviceInfoSeq list_device_types ();           ///< List registered Device types with their unique uri.
  DeviceSeq     list_devices      ();           ///< List devices in order of processing, notified via "devices".
  // create devices
  Device create_device        (String uuiduri); ///< Create a new device, see list_device_types().
  Device create_device_before (String uuiduri, Device sibling); ///< Create device, before sibling.
  bool   remove_device        (Device containee); ///< Remove a directly contained device.
};

/// Interface for sequencing information and links to Part objects.
interface Track : ContextMerger {
  SongTiming get_timing  (int32 tick);            ///< Retrieve song timing information at a specific tick.
  Part       create_part (int32 tick);            ///< Create a new Part in a Song.
  int32      insert_part (int32 tick, Part part); ///< Insert Part into Track at @a tick, returns the corresponding link id.
  void       remove_tick (int32 tick);            ///< Remove Part at specified @a tick from a track.
  void       remove_link (int32 id);              ///< Remove a specific part link by ID from a track.
  PartSeq      list_parts_uniq ();              ///< List all parts contained in a track.
  TrackPartSeq list_parts ();                   ///< List parts scheduled in a track, sorted by tick.
  Part         get_part (int32 tick);           ///< Get the part starting at a specific tick position.
  int32        get_last_tick ();                ///< Retrieve the last tick for this track.
  Error        ensure_output ();                ///< Ensure the track has an output connection to a bus.
  /// Get the output module of a track.
  /// The output of this module is the merged result from all polyphonic voices and has all track specific alterations applied.
  Source       get_output_source ();
  DeviceContainer device_container ();          ///< Retrieve the Device chain container of the Track.

  group _("Adjustments") {
    bool  muted = Bool (_("Muted"), _("Mute this track by ignoring it in the sequencer."), STANDARD SKIP_DEFAULT, false);
  };
  group _("MIDI Instrument") {
    int32 midi_channel = Range (_("MIDI Channel"), _("Midi channel assigned to this track, 0 uses internal per-track channel"),
                                GUI STORAGE ":scale:skip-default:unprepared", 0, MAX_MIDI_CHANNEL, 1, 0);
  };
  group _("Synth Input") {
    int32 n_voices = Range (_("Max Voices"), _("Maximum number of voices for simultaneous playback"),
			    GUI STORAGE ":scale:unprepared", 1, 64, 1, 1);
  };
  // property CSynth snet;         ///< _("Synthesis network to be used as instrument.")
  // property Wave wave;           ///< _("Wave to be used as instrument.")
  // property CSynth pnet;         ///< _("Synthesis network to be used as postprocessor.")
  ItemSeq outputs;      ///< _("Mixer busses used as output for this track.")
};

/// Sequence of Track objects.
sequence TrackSeq {
  Track tracks;
};

/// Record representing the use of a Part within a Track at a specific position.
record PartLink {
  Track track;
  int32 tick     = Range ("Tick", "", STANDARD, 0, MAXINT31, 384);
  Part  part;
  int32 duration = Range ("Duration", "", STANDARD, 0, MAXINT31, 384);
  // int32 count; // 1 + repetitions
};

/// Sequence of PartLink records.
sequence PartLinkSeq {
  PartLink plinks;
};

/// Structure linking to a Track from within a Part.
record TrackPart {
  int32 tick     = Range ("Tick", "", STANDARD, 0, MAXINT31, 384);
  Part  part;
  int32 duration = Range ("Duration", "", STANDARD, 0, MAXINT31, 384);
};

/// Sequence of TrackPart records.
sequence TrackPartSeq {
  TrackPart parts;
};

/// Interface for effect stacks and per-track audio signal routing to the master output.
interface Bus : SubSynth {
  Error ensure_output    ();            ///< Ensure that a bus has an output connection.
  Error connect_bus      (Bus bus);     ///< Add a bus to the input list of a bus.
  Error connect_track    (Track track); ///< Add a track to the input list of a bus.
  Error disconnect_bus   (Bus bus);     ///< Remove a bus from the input list of a bus.
  Error disconnect_track (Track track); ///< Remove a track from the input list of a bus.
  // ItemSeq   inputs        = Object ("Input Signals", "Synthesis signals (from tracks and busses) used as bus input", GUI ":item-sequence");
  // ItemSeq   outputs       = Object ("Output Signals", "Mixer busses used as output for synthesis signals", GUI ":item-sequence");
  // CSynth    snet          = Object ("SNet", "Synthesis network used internally to implement effect stack", READWRITE ":skip-undo");
  group _("Adjustments") {
    bool    mute         = Bool  (_("Mute"), _("Mute: turn off the bus volume"), STANDARD SKIP_DEFAULT, false);
    bool    solo         = Bool  (_("Solo"), _("Solo: mute all other busses"), STANDARD SKIP_DEFAULT, false);
    bool    sync         = Bool  (_("Sync"), _("Synchronize left and right volume"), STANDARD SKIP_DEFAULT, true);
    float64 left_volume  = Range (_("Left Volume"), _("Volume adjustment in decibel of left bus channel"), STANDARD ":scale:db-volume",
                                  BUS_VOLUME_MIN, BUS_VOLUME_MAX, BUS_VOLUME_STEP, BUS_VOLUME_DEF);
    float64 right_volume = Range (_("Right Volume"), _("Volume adjustment in decibel of right bus channel"), STANDARD ":scale:db-volume",
                                  BUS_VOLUME_MIN, BUS_VOLUME_MAX, BUS_VOLUME_STEP, BUS_VOLUME_DEF);
  };
  group _("Internals") {
    bool master_output = Bool (_("Master Output"), "", STORAGE SKIP_DEFAULT, false);
  };
};

/// Offsets for signal monitoring fields in bytes, field type and size is used as prefix.
enum SongTelemetry {
  I32_TICK_POINTER      =       0 * 4,  ///< Current song position pointer.
  BYTECOUNT             =       1 * 4,  ///< Total length of all fields.
};

/// Interface for Track and Part objects, as well as meta data for sequencing.
interface Song : SNet {
  SongTiming get_timing              (int32 tick);  ///< Retrieve song timing information at a specific tick.
  Track      find_any_track_for_part (Part part);   ///< Find the first track that contains part, suitable to check for orphan parts.
  Bus        create_bus              ();            ///< Create a new mixer bus for a Song.
  void       remove_bus              (Bus bus);     ///< Delete a mixer bus from a Song.
  Part       create_part             ();            ///< Create a new Part in a Song.
  void       remove_part             (Part part);   ///< Delete a Part from a Song.
  TrackSeq   list_tracks             ();            ///< List all tracks of this song.
  Track      create_track            ();            ///< Create a new Track for a Song.
  void       remove_track            (Track track); ///< Delete a Track from a Song.
  Bus        ensure_master_bus       ();            ///< Retrieve master output bus of a song, will create one if it doesn't exist.
  void       ensure_track_links      ();            ///< Ensure that each part in a song is inserted into at least one track.
  Track      find_track_for_part     (Part part);   ///< Find a track suitable for playing notes of a given part.
  Bus        get_master_bus          ();            ///< Retrieve master output bus of a song if it exists.
  /// Synthesize a note on a song of an active project.
  void       synthesize_note         (Track track, int32 duration, int32 note, int32 fine_tune, float64 velocity);
  int64      get_shm_offset          (SongTelemetry fld);   ///< Offset into SharedMemory for SongTelemetry fields.
  // signal void   pointer_changed (int32 a);
  // group _("MIDI Instrument") {
  // CSynth  pnet          = Object ("Postprocessor", "Synthesis network to be used as postprocessor", STANDARD);
  // };
  group _("Timing") {
    int32   tpqn          = Range (_("TPQN"), _("Number of ticks per quarter note"), STANDARD_RDONLY, 384, 384, 0, 384);
    int32   numerator     = Range (_("Numerator"), _("Measure numerator"), STANDARD, 1, 256, 1, 4);
    int32   denominator   = Range (_("Denominator"), _("Measure denominator, must be a power of 2"), STANDARD, 1, 256, 0, 4);
    float64 bpm           = Range (_("BPM"), _("Beats per minute"), STANDARD  ":scale", MIN_BPM, MAX_BPM, 10, 120);
  };
  group _("Tuning") {
    MusicalTuning musical_tuning = Enum (_("Musical Tuning"),
                                         _("The tuning system which specifies the tones or pitches to be used. "
                                           "Due to the psychoacoustic properties of tones, various pitch combinations can "
                                           "sound \"natural\" or \"pleasing\" when used in combination, the musical "
                                           "tuning system defines the number and spacing of frequency values applied."),
                                         STANDARD  ":unprepared");
  };
  group _("Looping") {
    bool  loop_enabled = Bool (_("Loop Enabled"), "", STORAGE SKIP_DEFAULT SKIP_UNDO, false);
    int32 loop_left    = Range (_("Loop Left"), "", STORAGE SKIP_DEFAULT SKIP_UNDO, -1, MAXINT31, 384, -1);
    int32 loop_right   = Range (_("Loop Right"), "", STORAGE SKIP_DEFAULT SKIP_UNDO, -1, MAXINT31, 384, -1);
    int32 tick_pointer = Range (_("Tick Pointer"), "", READWRITE SKIP_UNDO, -1, MAXINT31, 384, -1);
  };
};

///< Structure containing meta data for multi wave samples.
record SampleFileInfo {
  String     file    = String ("Filename", "", STANDARD);
  int64      size    = Range ("File Size", "File size in bytes", ":readwrite", 0, MAXINT63);
  int64      mtime   = Range ("MTime", "Last modification time in seconds", ":readwrite", 0, MAXINT63);
  String     loader  = String ("Loader", "Sample loader implementation", STANDARD);
  StringSeq  waves   = Sequence ("Waves", "List of embedded waves", STANDARD);
  Error      error   = Enum ("Error", "Indicator for errors during sample operation", STANDARD);
};

/// Interface for editable PCM wave samples.
interface EditableSample : Item {
  /** Collect statistics from sample blocks as (minimum, maximum) pairs.
   * @param voffset       Offset of first stat block
   * @param offset-scale  Factor to scale voffset increments with
   * @param block-size    Block size to compute stat pairs from
   * @param stepping      Stepping within a stat block
   * @param max-pairs     Maximum number of (min, max) pairs to collect
   * @return              Block of samples
   */
  FloatSeq    collect_stats  (int64 voffset, float64 offset_scale, int64 block_size, int64 stepping, int64 max_pairs);
  void        close          (); ///< Close an opened sample.
  int64       get_length     (); ///< Return the number of values in the sample.
  int64       get_n_channels (); ///< Return the number of channels in the sample.
  float64     get_osc_freq   (); ///< Return the oscillator frequency for the sample.
  Error       open           (); ///< Open the sample for reading.
  //signal void changed        (); ///< Signal indicating all sorts of possible changes.
};

/// Interface for PCM wave samples.
interface Wave : Source {
  float64        chunk_get_mix_freq    (int32 chunk_index); ///< Retrieve mixing frequency of a wave chunk.
  float64        chunk_get_osc_freq    (int32 chunk_index); ///< Retrieve oscillating frequency of a wave chunk.
  int32          n_wave_chunks         ();                  ///< Get the number of wave chunks of a wave.
  EditableSample use_editable          (int32 chunk_index); ///< Retrieve an editable sample object for a wave chunk.
};

/// Interface serving as container for Wave objects.
interface WaveRepo : Super {
  Error load_file   (String file_name);         ///< Load wave from file.
  void  remove_wave (Wave wave);                ///< Remove a wave from repository.
};

/// A list of part note events.
sequence WaveOscSeq {
  WaveOsc wave_oscs;
};

/// Oscillator module for wave files.
interface WaveOsc : Source {
  /// Seek a list of wave oscillators to a pcm position given in percentage. The oscillators will seek to the given position synchronously.
  void sync_seek_perc           (float64 pos_perc, WaveOscSeq wosc_seq);
  void request_pcm_position     ();                       ///< Request emission of the ::notify_pcm_position signal.
  void set_from_editable_sample (EditableSample esample); ///< Set wave to play from editable sample, bypassing undo and storage mechanisms.
  // signal void notify_pcm_position      (int64 timestamp, int64 position); ///< Notification signal containing the current PCM play position pointer.
  // Wave    wave           = ("Wave", "Wave used as oscillator source", STANDARD);
  // int64   channel        = Range ("Channel", "The audio channel to play, usually 1 is left, 2 is right", ":readwrite", 1, 256);
  // float64 fm_perc        = Range ("Input Modulation [%]", "Modulation Strength for linear frequency modulation", STANDARD  ":scale", 0, 100, 10);
  // bool    exponential_fm = Bool ("Exponential FM", "Perform exponential frequency modulation instead of linear", STANDARD, false);
  // float64 fm_n_octaves   = Range ("Octaves", "Number of octaves to be affected by exponential frequency modulation", STANDARD ":scale", 0, 3, 1);
};

/// Interface for sound fonts
interface SoundFont : Container {
};

interface SoundFontRepo : Super {
  Error load_file         (String file_name);         ///< Load sound font from file.
  Error remove_sound_font (SoundFont sound_font);     ///< Remove a sound font from repository.
};

/// Interface for MIDI synthesis networks.
interface MidiSynth : SNet {
  group _("MIDI Instrument") {
    int32 midi_channel = Range (_("MIDI Channel"), _("Midi channel assigned to this midi synthesizer"),
                                STANDARD ":scale:skip-default:unprepared",
                                1, MAX_MIDI_CHANNEL, 1, 1);
    int32 n_voices     = Range (_("Max Voices"), _("Maximum number of voices for simultaneous playback"),
                                STANDARD ":scale",
                                1, 256, 1, 16);
  };
  group _("Adjustments") {
    float64 volume_f    = Range (_("Master [float]"), "", STORAGE, 0, 15.8489319246111 /* +24dB */, 0.1, 1.0);
    float64 volume_dB   = Range (_("Master [dB]"), "", GUI ":dial", MIN_VOLUME_DB, MAX_VOLUME_DB, 0.1, 0);
    int32   volume_perc = Range (_("Master [%]"), "", GUI ":dial", 0, 1584 /* +24dB */, 1, 100);
  };
};

/// Enumeration describing the current activation and playback state of a project.
enum ProjectState {
  INACTIVE,     ///< The project is not yet hooked to the sound engine.
  ACTIVE,       ///< The sound engine is activated (rnuning) for this project.
  PLAYING       ///< The project is active and the sequencer is running.
};

/// Projects support loading, saving, playback and act as containers for all other sound objects.
interface Project : Container {
  // signal void  state_changed       (ProjectState newstate); ///< Signal notifies of project state changes.
  ProjectState get_state           (); ///< Retrieve the current project activation/playback state.
  void         change_name         (String name); ///< Change a project name without recording undo steps.
  Error        play                (); ///< Activate a project and start project playback (an already playing project is first halted).
  Error        activate            (); ///< Activate a project, precondition to start playback.
  bool         can_play            (); ///< Check whether project playback would makes sense.
  bool         is_playing          (); ///< Check whether a project is currently playing (song sequencing).
  bool         is_active           (); ///< Check whether a project is active (currently synthesizing).
  void         start_playback      (); ///< Start playback in an activated project.
  void         stop_playback       (); ///< Stop project playback.
  void         deactivate          (); ///< Deactivate the project, automatically stop playback.
  void         stop                (); ///< Stop project playback and deactivate project.
  void         auto_stop           (bool maystop); ///< Allow project to stop playback at the sequencing end.
  void         auto_deactivate     (int32 msec_delay); ///< Automatically deactivate a few milliseconds after playback stopped.
  int32        undo_depth          (); ///< Check whether a project can perform undo steps.
  void         undo                (); ///< Undo a previous operation in a project.
  int32        redo_depth          (); ///< Get the number of times redo can be called on the project.
  void         redo                (); ///< Redo a previously undone operation in a project.
  void         clear_undo          (); ///< Delete all recorded undo or redo steps.
  void         clean_dirty         (); ///< Clear a project's dirty flags.
  bool         is_dirty            (); ///< Check whether a project needs saving.
  SuperSeq     get_supers          (); ///< Retrieve all Super type objects of this project.
  Error        store               (String file_name, bool self_contained);     ///< Save project to file.
  Error        store_bse           (Container super, String file_name,
                                    bool self_contained);                       ///< Save effect or intrument.
  Song         create_song         (String name); ///< Create a song for this project.
  WaveRepo     get_wave_repo       ();            ///< Retrieve the project's unique wave repository.
  SoundFontRepo get_sound_font_repo ();            ///< Retrieve the project's unique sound font repository.
  CSynth       create_csynth       (String name); ///< Create a synthsizer network for this project.
  MidiSynth    create_midi_synth   (String name); ///< Create a MIDI synthesizer network for this project.
  void         remove_snet         (SNet snet);   ///< Remove an existing synthesizer network from this project.
  Error        restore_from_file   (String file_name); ///< Load a project from file.
  /// Inject a MIDI control event into the project's MIDI receiver.
  void         inject_midi_control (int32 midi_channel, int32 midi_control, float64 control_value);
  Error        import_midi_file    (String file_name); ///< Import a song from a MIDI file.
  //Item    find_item (String uname_path); ///< Find an item within a project, given its uname path.
  /// List uname paths for all items of a specified type within a project.
  /// By their uname paths, items are uniquely identifyable within a project.
  //StringSeq list_uname_paths (String item_type);
  /// Retrieve all items of a specific type within a project with matching uname.
  //ItemSeq match_items_by_uname (String item_type, String uname);
  /// Save super objects of a project into a BSE file.
  /// If no Super is specified, the project itself is stored.
  /// The references to other objects (e.g. samples) can be stored
  /// by reference (self_contained=false) or embedded in the output
  /// file (self_contained=true).
  group "State" {
    bool dirty = Bool ("Dirty", "Whether project needs saving", "r", false);
  };
};

/// Interface for writing PCM wave data.
interface PcmWriter : Item {
};

// == Bse Preferences ==
record Preferences {
  group _("Synthesis Settings") {
    String pcm_driver        = String (_("PCM Driver"), _("Driver and device to be used for PCM input and output"), STANDARD);
    int32 synth_latency      = Range (_("Latency [ms]"),
                                      _("Processing duration between input and output of a single sample, smaller values increase CPU load"),
                                      STANDARD, 0, 3000, 5);
    int32 synth_mixing_freq  = Range (_("Synth Mixing Frequency"),
                                      _("Unused, synthesis mixing frequency is always 48000 Hz"), "r", 48000, 48000);
    int32 synth_control_freq = Range (_("Synth Control Frequency"),
                                      _("Unused frequency setting"), "r", 1500, 1500);
  };
  group _("MIDI") {
    String midi_driver     = String (_("MIDI Driver"), _("Driver and device to be used for MIDI input and output"), STANDARD);
    bool   invert_sustain  = Bool (_("Invert Sustain Pedal"), _("Invert the state of sustain (damper) pedal so on/off meanings are reversed"), STANDARD);
  };
  group _("Default Values") {
    String author_default  = String (_("Default Author"), _("Default value for 'Author' fields"), STANDARD);
    String license_default = String (_("Default License"), _("Default value for 'License' fields"), STANDARD);
  };
  group _("Search Paths") {
    String sample_path     = String (_("Sample Path"), _("Search path of directories, seperated by \";\", used to find audio samples."),
                                     STANDARD ":searchpath");
    String effect_path     = String (_("Effect Path"), _("Search path of directories, seperated by \";\", used to find BSE effect files."),
                                     STANDARD ":searchpath");
    String instrument_path = String (_("Instrument Path"), _("Search path of directories, seperated by \";\", used to find BSE instrument files."),
                                     STANDARD ":searchpath");
    String plugin_path     = String (_("Plugin Path"),
                                     _("Search path of directories, seperated by \";\", used to find BSE plugins. This path "
                                       "is searched for in addition to the standard BSE plugin location on this system."),
                                     STANDARD ":searchpath");
  };
};

/// Categories describe useful type entities.
record Category
{
  int32  category_id = Num ("Category ID", "", ":readwrite");
  String category;
  int32  mindex;
  int32  lindex;
  String otype;
  Icon   icon;
};

/// Sequence of Category records.
sequence CategorySeq {
  Category cats;
};

/// Origin or collection of resource classes.
enum ResourceOrigin {
  NONE                  = 0,
  // STANDARD_LIBRARY      = 1,
  // PACKAGE_LIBRARY       = 2,
  // SYSTEM_LIBRARY        = 3,
  // USER_LIBRARY          = 4,
  USER_DOWNLOADS        = 5,
  // FAVORITES             = 6,
  // AUDIO_DEVICES         = 7,
};

/// Classification for various resource listings.
enum ResourceType {
  NONE                  = 0,
  FOLDER                = 1,
  AUDIO_DEVICE          = 2,
  // PRESET             = 4,
  FILE                  = 100,
  WAVE                  = 101,          ///< Multi channel audio sample.
  SOUNDFONT             = 102,          ///< Layered sample instrument bank.
};

record ResourceEntry;
sequence ResourceList { ResourceEntry entries; };

/// Description of a resource, possibly nested.
record ResourceEntry {
  ResourceType type;        ///< Resource classification.
  String       uri;         ///< Unique identifier for a resource.
  String       label;       ///< Preferred user interface name.
  String       category;    ///< Category of resource, often used for logical grouping.
  String       blurb;       ///< Short description for a resource.
  String       hints;       ///< Colon separated `key=value` pairs.
  ResourceList entries;     ///< Subentry list for nested resources.
};

interface ResourceCrawler : Object {
  ResourceList list_files   (ResourceType file_type, ResourceOrigin file_origin); ///< List WAVE / SOUNDFONT files.
  ResourceList list_devices (ResourceType rtype);       ///< List AUDIO_DEVICE resources.
};

/// Driver information for PCM and MIDI handling.
record DriverEntry {
  String devid;
  String device_name;
  String capabilities;
  String device_info;
  String notice;
  int32  priority;
  bool   readonly;
  bool   writeonly;
  bool   modem;
};

/// DriverEntry sequence.
sequence DriverEntrySeq {
  DriverEntry entries;
};

/// Fragment description for interesting bits of shared memory.
record ShmFragment {
  int64 shmoffset;
  int32 blength;
  int32 bpos;
};

/// Collection of shared memory fragments.
sequence ShmFragmentSeq {
  ShmFragment frags;
};

/** Main Bse remote origin object.
 * The Bse::Server object controls the main BSE thread and keeps track of all objects
 * used in the BSE context.
 *
 * ### Events:
 * - **enginechange** - A notification event for DSP engine changes, the event field *active* contains the activation state.
 * - **usermessage**  - A notification event with information relevant to the user.
 */
interface Server : Container {
  // signal void   user_message      (UserMessage umsg);   ///< Notification signal for user messages from BSE.
  void          send_user_message (UserMessage umsg);   ///< Send a user messages from BSE.
  LegacyObject       from_proxy      (int64 proxyid);        ///< Find an Object from its associated BseObject proxy id.
  bool          engine_active   ();                     ///< Retrieve DSP engine activateion state, see also: "enginechange" Event.
  String        get_mp3_version ();                     ///< Retrieve BSE MP3 handler version.
  String        get_vorbis_version ();                  ///< Retrieve BSE Vorbis handler version.
  String        get_ladspa_path ();                     ///< Retrieve ladspa search path.
  String        get_plugin_path ();                     ///< Retrieve plugin search path.
  String        get_instrument_path ();                 ///< Retrieve instrument search path.
  String        get_sample_path ();                     ///< Retrieve sample search path.
  String        get_effect_path ();                     ///< Retrieve effect search path.
  String        get_demo_path ();                       ///< Retrieve demo search path.
  String        get_custom_instrument_dir ();           ///< Retrieve user specific instruments directory.
  String        get_custom_effect_dir ();    ///< Retrieve user specific effects directory.
  String        get_version ();              ///< Retrieve BSE version.
  void          purge_stale_cachedirs   ();  ///< Purge stale directories from past runtimes.
  void          load_assets();               ///< Load factory plugins and scripts.
  void          load_ladspa();               ///< Load external LADSPA plugins.
  bool          can_load (String file_name); ///< Check whether a loader can be found for a wave file.
  void          start_recording (String wave_file, float64 n_seconds); ///< Start recording to a WAV file.
  Project       create_project  (String project_name); ///< Create a new project (name is modified to be unique if necessary.
  Project       last_project    ();                    ///< Retrieve the last created project.
  AuxDataSeq     list_module_types ();                   ///< A list of Source type names for create_source().
  AuxData        find_module_type  (String module_type); ///< Retrieve info about a Source type names.
  Icon           module_type_icon  (String module_type); ///< Retrieve the icon associated with a module type.
  SampleFileInfo sample_file_info  (String file_name); ///< Load sample file info from file.
  void           broadcast_shm_fragments (ShmFragmentSeq plan,
                                          int32 interval_ms);   ///< Broadcast shared memory fragments to the current Jsonipc connection.
  SharedMemory   get_shared_memory ();                  ///< Retrieve global SharedMemory information.
  Preferences    get_default_prefs ();                  ///< Retrieve Bse::Preferences setting defaults.
  void           set_prefs         (Preferences prefs); ///< Assign updated Bse::Preferences settings.
  Preferences    get_prefs         ();                  ///< Retrieve Bse::Preferences settings.
  bool           locked_prefs      ();  ///< Returns whether `Preferences` is in use and locked against modifications.
  DriverEntrySeq list_pcm_drivers  ();  ///< List available drivers for PCM input/output handling.
  DriverEntrySeq list_midi_drivers ();  ///< List available drivers for MIDI input/output handling.
  ResourceCrawler resource_crawler ();  ///< Retrieve interface for listing resources.

  // properties
  group "Misc" {
    bool   log_messages = Bool ("Log Messages", "Log messages through the log system", GUI, true);
  };
  group "PCM Recording" {
    String wave_file    = String (_("WAVE File"), _("Name of the WAVE file used for recording BSE sound output"), GUI ":filename");
  };
  /// Describe a note, providing information about its octave, semitone, frequency, etc.
  NoteDescription note_describe (MusicalTuning musical_tuning, int32 note, int32 fine_tune);
  // Describe a note, given its frequency.
  NoteDescription note_describe_from_freq (MusicalTuning musical_tuning, float64 freq);
  /// Describe a note, given its semitone, octave and fine tune.
  NoteDescription note_construct (MusicalTuning musical_tuning, int32 semitone, int32 octave, int32 fine_tune);
  /// Describe a note, given its name and octave offset.
  NoteDescription note_from_string (MusicalTuning musical_tuning, String name);
  /// Retrieve the note of a certain frequency.
  int32           note_from_freq (MusicalTuning musical_tuning, float64 frequency);
  /// Retrieve the frequency of a certain note.
  float64         note_to_freq (MusicalTuning musical_tuning, int32 note, int32 fine_tune);

  CategorySeq category_match_typed (String pattern, String type_name); ///< List BSE categories according to a pattern and type match.
  CategorySeq category_match       (String pattern);                   ///< List BSE categories according to a pattern match.

  /// Helper for Wave PCM positioning.
  int64       tick_stamp_from_systime (int64 systime_usecs);

  /// Testing, increment and return the resulting test counter value.
  int32       test_counter_inc_fetch  ();
  int32       test_counter_get        ();
  void        test_counter_set        (int32 val);
};

} // Bse
