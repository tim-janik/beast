// Licensed GNU LGPL v2.1 or later: http://www.gnu.org/licenses/lgpl.html -*-mode:c++;-*-
/**
 * @file
 * @brief Public BSE interface classes.
 */

namespace Bse {

// == Type Constants ==
Const MAXINT63   = +9223372036854775807;
Const MAXINT32   = +4294967295;
Const MAXINT31   = +2147483647;
Const MININT31   = -2147483648;
Const MAXFLOAT64 = 1.7976931348623157e+308;

// == Enums ==
enum Error {
  NONE                      = Enum (0, "", _("OK")),
  INTERNAL                  = Enum (1, "", _("Internal error (please report)")),
  UNKNOWN                   = Enum (2, "", _("Unknown error")),
  IO                        = Enum (3, "", _("Input/output error")),
  PERMS                     = Enum (4, "", _("Insufficient permissions")),
  // file errors
  FILE_BUSY                 = Enum (5, "", _("Device or resource busy")),
  FILE_EXISTS               = Enum (6, "", _("File exists already")),
  FILE_EOF                  = Enum (7, "", _("End of file")),
  FILE_EMPTY                = Enum (8, "", _("File empty")),
  FILE_NOT_FOUND            = Enum (9, "", _("No such file, device or directory")),
  FILE_IS_DIR               = Enum (10, "", _("Is a directory")),
  FILE_OPEN_FAILED          = Enum (11, "", _("Open failed")),
  FILE_SEEK_FAILED          = Enum (12, "", _("Seek failed")),
  FILE_READ_FAILED          = Enum (13, "", _("Read failed")),
  FILE_WRITE_FAILED         = Enum (14, "", _("Write failed")),
  // out of resource conditions
  MANY_FILES                = Enum (15, "", _("Too many open files")),
  NO_FILES                  = Enum (16, "", _("Too many open files in system")),
  NO_SPACE                  = Enum (17, "", _("No space left on device")),
  NO_MEMORY                 = Enum (18, "", _("Out of memory")),
  // content errors
  NO_HEADER                 = Enum (19, "", _("Failed to detect header")),
  NO_SEEK_INFO              = Enum (20, "", _("Failed to retrieve seek information")),
  NO_DATA                   = Enum (21, "", _("No data available")),
  DATA_CORRUPT              = Enum (22, "", _("Data corrupt")),
  WRONG_N_CHANNELS          = Enum (23, "", _("Wrong number of channels")),
  FORMAT_INVALID            = Enum (24, "", _("Invalid format")),
  FORMAT_UNKNOWN            = Enum (25, "", _("Unknown format")),
  DATA_UNMATCHED            = Enum (26, "", _("Requested data values unmatched")),
  // miscellaneous errors
  TEMP                      = Enum (27, "", _("Temporary error")),
  WAVE_NOT_FOUND            = Enum (28, "", _("No such wave")),
  CODEC_FAILURE             = Enum (29, "", _("Codec failure")),
  UNIMPLEMENTED             = Enum (30, "", _("Functionality not implemented")),
  INVALID_PROPERTY          = Enum (31, "", _("Invalid object property")),
  INVALID_MIDI_CONTROL      = Enum (32, "", _("Invalid MIDI control type")),
  PARSE_ERROR               = Enum (33, "", _("Parsing error")),
  SPAWN                     = Enum (34, "", _("Failed to spawn child process")),
  // Device errors
  DEVICE_NOT_AVAILABLE      = Enum (35, "", _("No device (driver) available")),
  DEVICE_ASYNC              = Enum (36, "", _("Device not async capable")),
  DEVICE_BUSY               = Enum (37, "", _("Device busy")),
  DEVICE_FORMAT             = Enum (38, "", _("Failed to configure device format")),
  DEVICE_BUFFER             = Enum (39, "", _("Failed to configure device buffer")),
  DEVICE_LATENCY            = Enum (40, "", _("Failed to configure device latency")),
  DEVICE_CHANNELS           = Enum (41, "", _("Failed to configure number of device channels")),
  DEVICE_FREQUENCY          = Enum (42, "", _("Failed to configure device frequency")),
  DEVICES_MISMATCH          = Enum (43, "", _("Device configurations mismatch")),
  // BseSource errors
  SOURCE_NO_SUCH_MODULE     = Enum (44, "", _("No such synthesis module")),
  SOURCE_NO_SUCH_ICHANNEL   = Enum (45, "", _("No such input channel")),
  SOURCE_NO_SUCH_OCHANNEL   = Enum (46, "", _("No such output channel")),
  SOURCE_NO_SUCH_CONNECTION = Enum (47, "", _("Input/Output channels not connected")),
  SOURCE_PRIVATE_ICHANNEL   = Enum (48, "", _("Input channel is private")),
  SOURCE_ICHANNEL_IN_USE    = Enum (49, "", _("Input channel already in use")),
  SOURCE_CHANNELS_CONNECTED = Enum (50, "", _("Input/output channels already connected")),
  SOURCE_CONNECTION_INVALID = Enum (51, "", _("Invalid synthesis module connection")),
  SOURCE_PARENT_MISMATCH    = Enum (52, "", _("Parent mismatch")),
  SOURCE_BAD_LOOPBACK       = Enum (53, "", _("Bad loopback")),
  SOURCE_BUSY               = Enum (54, "", _("Synthesis module currently busy")),
  SOURCE_TYPE_INVALID       = Enum (55, "", _("Invalid synthsis module type")),
  // BseProcedure errors
  PROC_NOT_FOUND            = Enum (56, "", _("No such procedure")),
  PROC_BUSY                 = Enum (57, "", _("Procedure currently busy")),
  PROC_PARAM_INVAL          = Enum (58, "", _("Procedure parameter invalid")),
  PROC_EXECUTION            = Enum (59, "", _("Procedure execution failed")),
  PROC_ABORT                = Enum (60, "", _("Procedure execution aborted")),
  // various procedure errors
  NO_ENTRY                  = Enum (61, "", _("No such entry")),
  NO_EVENT                  = Enum (62, "", _("No such event")),
  NO_TARGET                 = Enum (63, "", _("No target")),
  NOT_OWNER                 = Enum (64, "", _("Ownership mismatch")),
  INVALID_OFFSET            = Enum (65, "", _("Invalid offset")),
  INVALID_DURATION          = Enum (66, "", _("Invalid duration")),
  INVALID_OVERLAP           = Enum (67, "", _("Invalid overlap")),
};

enum MidiSignal {
  // special case signals
  PROGRAM                   = Enum (1,   _("Program Change")),     // 7bit
  PRESSURE                  = Enum (2,   _("Channel Pressure")),   // 7bit
  PITCH_BEND                = Enum (3,   _("Pitch Bend")),         // 14bit
  VELOCITY                  = Enum (4,   _("Note Velocity")),
  FINE_TUNE                 = Enum (5,   _("Note Fine Tune")),
  // 14bit, continuous controls
  CONTINUOUS_0              = Enum (64,  _("Bank Select")),
  CONTINUOUS_1              = Enum (65,  _("Modulation Depth")),
  CONTINUOUS_2              = Enum (66,  _("Breath Control")),
  CONTINUOUS_3              = Enum (67,  _("Continuous 3")),
  CONTINUOUS_4              = Enum (68,  _("Foot Controller")),
  CONTINUOUS_5              = Enum (69,  _("Portamento Time")),
  CONTINUOUS_6              = Enum (70,  _("Data Entry")),
  CONTINUOUS_7              = Enum (71,  _("Volume")),
  CONTINUOUS_8              = Enum (72,  _("Balance")),
  CONTINUOUS_9              = Enum (73,  _("Continuous 9")),
  CONTINUOUS_10             = Enum (74,  _("Panorama")),
  CONTINUOUS_11             = Enum (75,  _("Expression")),
  CONTINUOUS_12             = Enum (76,  _("Effect Control 1")),
  CONTINUOUS_13             = Enum (77,  _("Effect Control 2")),
  CONTINUOUS_14             = Enum (78,  _("Continuous 14")),
  CONTINUOUS_15             = Enum (79,  _("Continuous 15")),
  CONTINUOUS_16             = Enum (80,  _("General Purpose Controller 1")),
  CONTINUOUS_17             = Enum (81,  _("General Purpose Controller 2")),
  CONTINUOUS_18             = Enum (82,  _("General Purpose Controller 3")),
  CONTINUOUS_19             = Enum (83,  _("General Purpose Controller 4")),
  CONTINUOUS_20             = Enum (84,  _("Continuous 20")),
  CONTINUOUS_21             = Enum (85,  _("Continuous 21")),
  CONTINUOUS_22             = Enum (86,  _("Continuous 22")),
  CONTINUOUS_23             = Enum (87,  _("Continuous 23")),
  CONTINUOUS_24             = Enum (88,  _("Continuous 24")),
  CONTINUOUS_25             = Enum (89,  _("Continuous 25")),
  CONTINUOUS_26             = Enum (90,  _("Continuous 26")),
  CONTINUOUS_27             = Enum (91,  _("Continuous 27")),
  CONTINUOUS_28             = Enum (92,  _("Continuous 28")),
  CONTINUOUS_29             = Enum (93,  _("Continuous 29")),
  CONTINUOUS_30             = Enum (94,  _("Continuous 30")),
  CONTINUOUS_31             = Enum (95,  _("Continuous 31")),
  // 14bit, special case signals
  CONSTANT_HIGH             = Enum (96,  _("Constant HIGH")),
  CONSTANT_CENTER           = Enum (97,  _("Constant CENTER")),
  CONSTANT_LOW              = Enum (98,  _("Constant LOW")),
  CONSTANT_NEGATIVE_CENTER  = Enum (99,  _("Constant Negative CENTER")),
  CONSTANT_NEGATIVE_HIGH    = Enum (100, _("Constant Negative HIGH")),
  PARAMETER                 = Enum (101, _("Registered Parameter")),
  NON_PARAMETER             = Enum (102, _("Non-Registered Parameter")),
  // 7bit, literal channel controls, MSB values
  CONTROL_0                 = Enum (128, _("Control 0 Bank Select MSB")),
  CONTROL_1                 = Enum (129, _("Control 1 Modulation Depth MSB")),
  CONTROL_2                 = Enum (130, _("Control 2 Breath Control MSB")),
  CONTROL_3                 = Enum (131, _("control-3")),
  CONTROL_4                 = Enum (132, _("Control 4 Foot Controller MSB")),
  CONTROL_5                 = Enum (133, _("Control 5 Portamento Time MSB")),
  CONTROL_6                 = Enum (134, _("Control 6 Data Entry MSB")),
  CONTROL_7                 = Enum (135, _("Control 7 Volume MSB")),
  CONTROL_8                 = Enum (136, _("Control 8 Balance MSB")),
  CONTROL_9                 = Enum (137, _("control-9")),
  CONTROL_10                = Enum (138, _("Control 10 Panorama MSB")),
  CONTROL_11                = Enum (139, _("Control 11 Expression MSB")),
  CONTROL_12                = Enum (140, _("Control 12 Effect Control 1 MSB")),
  CONTROL_13                = Enum (141, _("Control 13 Effect Control 2 MSB")),
  CONTROL_14                = Enum (142, _("control-14")),
  CONTROL_15                = Enum (143, _("control-15")),
  CONTROL_16                = Enum (144, _("Control 16 General Purpose Controller 1 MSB")),
  CONTROL_17                = Enum (145, _("Control 17 General Purpose Controller 2 MSB")),
  CONTROL_18                = Enum (146, _("Control 18 General Purpose Controller 3 MSB")),
  CONTROL_19                = Enum (147, _("Control 19 General Purpose Controller 4 MSB")),
  CONTROL_20                = Enum (148, _("control-20")),
  CONTROL_21                = Enum (149, _("control-21")),
  CONTROL_22                = Enum (150, _("control-22")),
  CONTROL_23                = Enum (151, _("control-23")),
  CONTROL_24                = Enum (152, _("control-24")),
  CONTROL_25                = Enum (153, _("control-25")),
  CONTROL_26                = Enum (154, _("control-26")),
  CONTROL_27                = Enum (155, _("control-27")),
  CONTROL_28                = Enum (156, _("control-28")),
  CONTROL_29                = Enum (157, _("control-29")),
  CONTROL_30                = Enum (158, _("control-30")),
  CONTROL_31                = Enum (159, _("control-31")),
  // 7bit, literal channel controls, LSB values
  CONTROL_32                = Enum (160, _("Control 32 Bank Select LSB")),
  CONTROL_33                = Enum (161, _("Control 33 Modulation Depth LSB")),
  CONTROL_34                = Enum (162, _("Control 34 Breath Control LSB")),
  CONTROL_35                = Enum (163, _("control-35")),
  CONTROL_36                = Enum (164, _("Control 36 Foot Controller LSB")),
  CONTROL_37                = Enum (165, _("Control 37 Portamento Time LSB")),
  CONTROL_38                = Enum (166, _("Control 38 Data Entry LSB")),
  CONTROL_39                = Enum (167, _("Control 39 Volume LSB")),
  CONTROL_40                = Enum (168, _("Control 40 Balance LSB")),
  CONTROL_41                = Enum (169, _("control-41")),
  CONTROL_42                = Enum (170, _("Control 42 Panorama LSB")),
  CONTROL_43                = Enum (171, _("Control 43 Expression LSB")),
  CONTROL_44                = Enum (172, _("Control 44 Effect Control 1 LSB")),
  CONTROL_45                = Enum (173, _("Control 45 Effect Control 2 LSB")),
  CONTROL_46                = Enum (174, _("control-46")),
  CONTROL_47                = Enum (175, _("control-47")),
  CONTROL_48                = Enum (176, _("Control 48 General Purpose Controller 1 LSB")),
  CONTROL_49                = Enum (177, _("Control 49 General Purpose Controller 2 LSB")),
  CONTROL_50                = Enum (178, _("Control 50 General Purpose Controller 3 LSB")),
  CONTROL_51                = Enum (179, _("Control 51 General Purpose Controller 4 LSB")),
  CONTROL_52                = Enum (180, _("control-52")),
  CONTROL_53                = Enum (181, _("control-53")),
  CONTROL_54                = Enum (182, _("control-54")),
  CONTROL_55                = Enum (183, _("control-55")),
  CONTROL_56                = Enum (184, _("control-56")),
  CONTROL_57                = Enum (185, _("control-57")),
  CONTROL_58                = Enum (186, _("control-58")),
  CONTROL_59                = Enum (187, _("control-59")),
  CONTROL_60                = Enum (188, _("control-60")),
  CONTROL_61                = Enum (189, _("control-61")),
  CONTROL_62                = Enum (190, _("control-62")),
  CONTROL_63                = Enum (191, _("control-63")),
  // 7bit, literal channel controls
  CONTROL_64                = Enum (192, _("Control 64 Damper Pedal Switch (Sustain)")),
  CONTROL_65                = Enum (193, _("Control 65 Portamento Switch")),
  CONTROL_66                = Enum (194, _("Control 66 Sustenuto Switch")),
  CONTROL_67                = Enum (195, _("Control 67 Soft Switch")),
  CONTROL_68                = Enum (196, _("Control 68 Legato Pedal Switch")),
  CONTROL_69                = Enum (197, _("Control 69 Hold Pedal Switch")),
  CONTROL_70                = Enum (198, _("Control 70 Sound Variation")),
  CONTROL_71                = Enum (199, _("Control 71 Filter Resonance (Timbre)")),
  CONTROL_72                = Enum (200, _("Control 72 Sound Release Time")),
  CONTROL_73                = Enum (201, _("Control 73 Sound Attack Time")),
  CONTROL_74                = Enum (202, _("Control 74 Sound Brightness")),
  CONTROL_75                = Enum (203, _("Control 75 Sound Decay Time")),
  CONTROL_76                = Enum (204, _("Control 76 Vibrato Rate")),
  CONTROL_77                = Enum (205, _("Control 77 Vibrato Depth")),
  CONTROL_78                = Enum (206, _("Control 78 Vibrato Delay")),
  CONTROL_79                = Enum (207, _("Control 79 Sound Control 10")),
  CONTROL_80                = Enum (208, _("Control 80 General Purpose Switch 5")),
  CONTROL_81                = Enum (209, _("Control 81 General Purpose Switch 6")),
  CONTROL_82                = Enum (210, _("Control 82 General Purpose Switch 7")),
  CONTROL_83                = Enum (211, _("Control 83 General Purpose Switch 8")),
  CONTROL_84                = Enum (212, _("Control 84 Portamento Control (Note)")),
  CONTROL_85                = Enum (213, _("control-85")),
  CONTROL_86                = Enum (214, _("control-86")),
  CONTROL_87                = Enum (215, _("control-87")),
  CONTROL_88                = Enum (216, _("control-88")),
  CONTROL_89                = Enum (217, _("control-89")),
  CONTROL_90                = Enum (218, _("control-90")),
  CONTROL_91                = Enum (219, _("Control 91 Reverb Depth")),
  CONTROL_92                = Enum (220, _("Control 92 Tremolo Depth")),
  CONTROL_93                = Enum (221, _("Control 93 Chorus Depth")),
  CONTROL_94                = Enum (222, _("Control 93 Detune Depth")),
  CONTROL_95                = Enum (223, _("Control 95 Phase Depth")),
  CONTROL_96                = Enum (224, _("Control 96 Data Increment Trigger")),
  CONTROL_97                = Enum (225, _("Control 97 Data Decrement Trigger")),
  CONTROL_98                = Enum (226, _("Control 98 Non-Registered Parameter MSB")),
  CONTROL_99                = Enum (227, _("Control 99 Non-Registered Parameter LSB")),
  CONTROL_100               = Enum (228, _("Control 100 Registered Parameter MSB")),
  CONTROL_101               = Enum (229, _("Control 101 Registered Parameter LSB")),
  CONTROL_102               = Enum (230, _("control-102")),
  CONTROL_103               = Enum (231, _("control-103")),
  CONTROL_104               = Enum (232, _("control-104")),
  CONTROL_105               = Enum (233, _("control-105")),
  CONTROL_106               = Enum (234, _("control-106")),
  CONTROL_107               = Enum (235, _("control-107")),
  CONTROL_108               = Enum (236, _("control-108")),
  CONTROL_109               = Enum (237, _("control-109")),
  CONTROL_110               = Enum (238, _("control-110")),
  CONTROL_111               = Enum (239, _("control-111")),
  CONTROL_112               = Enum (240, _("control-112")),
  CONTROL_113               = Enum (241, _("control-113")),
  CONTROL_114               = Enum (242, _("control-114")),
  CONTROL_115               = Enum (243, _("control-115")),
  CONTROL_116               = Enum (244, _("control-116")),
  CONTROL_117               = Enum (245, _("control-117")),
  CONTROL_118               = Enum (246, _("control-118")),
  CONTROL_119               = Enum (247, _("control-119")),
  CONTROL_120               = Enum (248, _("Control 120 All Sound Off ITrigger")),
  CONTROL_121               = Enum (249, _("Control 121 All Controllers Off ITrigger")),
  CONTROL_122               = Enum (250, _("Control 122 Local Control Switch")),
  CONTROL_123               = Enum (251, _("Control 123 All Notes Off ITrigger")),
  CONTROL_124               = Enum (252, _("Control 124 Omni Mode Off ITrigger")),
  CONTROL_125               = Enum (253, _("Control 125 Omni Mode On ITrigger")),
  CONTROL_126               = Enum (254, _("Control 126 Monophonic Voices Mode")),
  CONTROL_127               = Enum (255, _("Control 127 Polyphonic Mode On ITrigger")),
};

enum MidiControl {
  // special cased signals
  NONE                  = Enum (0, _("None")),
  // 14bit, continuous controls
  CONTINUOUS_0          = Enum (64,  _("Bank Select"), _("Continuous MIDI Control #1 - Bank Select")),
  CONTINUOUS_1          = Enum (65,  _("Modulation Depth")),
  CONTINUOUS_2          = Enum (66,  _("Breath Control")),
  CONTINUOUS_3          = Enum (67,  _("Continuous 3")),
  CONTINUOUS_4          = Enum (68,  _("Foot Controller")),
  CONTINUOUS_5          = Enum (69,  _("Portamento Time")),
  CONTINUOUS_6          = Enum (70,  _("Data Entry")),
  CONTINUOUS_7          = Enum (71,  _("Volume")),
  CONTINUOUS_8          = Enum (72,  _("Balance")),
  CONTINUOUS_9          = Enum (73,  _("Continuous 9")),
  CONTINUOUS_10         = Enum (74,  _("Panorama")),
  CONTINUOUS_11         = Enum (75,  _("Expression")),
  CONTINUOUS_12         = Enum (76,  _("Effect Control 1")),
  CONTINUOUS_13         = Enum (77,  _("Effect Control 2")),
  CONTINUOUS_14         = Enum (78,  _("Continuous 14")),
  CONTINUOUS_15         = Enum (79,  _("Continuous 15")),
  CONTINUOUS_16         = Enum (80,  _("General Purpose Controller 1")),
  CONTINUOUS_17         = Enum (81,  _("General Purpose Controller 2")),
  CONTINUOUS_18         = Enum (82,  _("General Purpose Controller 3")),
  CONTINUOUS_19         = Enum (83,  _("General Purpose Controller 4")),
  CONTINUOUS_20         = Enum (84,  _("Continuous 20")),
  CONTINUOUS_21         = Enum (85,  _("Continuous 21")),
  CONTINUOUS_22         = Enum (86,  _("Continuous 22")),
  CONTINUOUS_23         = Enum (87,  _("Continuous 23")),
  CONTINUOUS_24         = Enum (88,  _("Continuous 24")),
  CONTINUOUS_25         = Enum (89,  _("Continuous 25")),
  CONTINUOUS_26         = Enum (90,  _("Continuous 26")),
  CONTINUOUS_27         = Enum (91,  _("Continuous 27")),
  CONTINUOUS_28         = Enum (92,  _("Continuous 28")),
  CONTINUOUS_29         = Enum (93,  _("Continuous 29")),
  CONTINUOUS_30         = Enum (94,  _("Continuous 30")),
  CONTINUOUS_31         = Enum (95,  _("Continuous 31")),
  // 7bit, literal channel controls, MSB values
  CONTROL_0             = Enum (128, _("Control 0 Bank Select MSB")),
  CONTROL_1             = Enum (129, _("Control 1 Modulation Depth MSB")),
  CONTROL_2             = Enum (130, _("Control 2 Breath Control MSB")),
  CONTROL_3             = Enum (131, _("control-3")),
  CONTROL_4             = Enum (132, _("Control 4 Foot Controller MSB")),
  CONTROL_5             = Enum (133, _("Control 5 Portamento Time MSB")),
  CONTROL_6             = Enum (134, _("Control 6 Data Entry MSB")),
  CONTROL_7             = Enum (135, _("Control 7 Volume MSB")),
  CONTROL_8             = Enum (136, _("Control 8 Balance MSB")),
  CONTROL_9             = Enum (137, _("control-9")),
  CONTROL_10            = Enum (138, _("Control 10 Panorama MSB")),
  CONTROL_11            = Enum (139, _("Control 11 Expression MSB")),
  CONTROL_12            = Enum (140, _("Control 12 Effect Control 1 MSB")),
  CONTROL_13            = Enum (141, _("Control 13 Effect Control 2 MSB")),
  CONTROL_14            = Enum (142, _("control-14")),
  CONTROL_15            = Enum (143, _("control-15")),
  CONTROL_16            = Enum (144, _("Control 16 General Purpose Controller 1 MSB")),
  CONTROL_17            = Enum (145, _("Control 17 General Purpose Controller 2 MSB")),
  CONTROL_18            = Enum (146, _("Control 18 General Purpose Controller 3 MSB")),
  CONTROL_19            = Enum (147, _("Control 19 General Purpose Controller 4 MSB")),
  CONTROL_20            = Enum (148, _("control-20")),
  CONTROL_21            = Enum (149, _("control-21")),
  CONTROL_22            = Enum (150, _("control-22")),
  CONTROL_23            = Enum (151, _("control-23")),
  CONTROL_24            = Enum (152, _("control-24")),
  CONTROL_25            = Enum (153, _("control-25")),
  CONTROL_26            = Enum (154, _("control-26")),
  CONTROL_27            = Enum (155, _("control-27")),
  CONTROL_28            = Enum (156, _("control-28")),
  CONTROL_29            = Enum (157, _("control-29")),
  CONTROL_30            = Enum (158, _("control-30")),
  CONTROL_31            = Enum (159, _("control-31")),
  // 7bit, literal channel controls, LSB values
  CONTROL_32            = Enum (160, _("Control 32 Bank Select LSB")),
  CONTROL_33            = Enum (161, _("Control 33 Modulation Depth LSB")),
  CONTROL_34            = Enum (162, _("Control 34 Breath Control LSB")),
  CONTROL_35            = Enum (163, _("control-35")),
  CONTROL_36            = Enum (164, _("Control 36 Foot Controller LSB")),
  CONTROL_37            = Enum (165, _("Control 37 Portamento Time LSB")),
  CONTROL_38            = Enum (166, _("Control 38 Data Entry LSB")),
  CONTROL_39            = Enum (167, _("Control 39 Volume LSB")),
  CONTROL_40            = Enum (168, _("Control 40 Balance LSB")),
  CONTROL_41            = Enum (169, _("control-41")),
  CONTROL_42            = Enum (170, _("Control 42 Panorama LSB")),
  CONTROL_43            = Enum (171, _("Control 43 Expression LSB")),
  CONTROL_44            = Enum (172, _("Control 44 Effect Control 1 LSB")),
  CONTROL_45            = Enum (173, _("Control 45 Effect Control 2 LSB")),
  CONTROL_46            = Enum (174, _("control-46")),
  CONTROL_47            = Enum (175, _("control-47")),
  CONTROL_48            = Enum (176, _("Control 48 General Purpose Controller 1 LSB")),
  CONTROL_49            = Enum (177, _("Control 49 General Purpose Controller 2 LSB")),
  CONTROL_50            = Enum (178, _("Control 50 General Purpose Controller 3 LSB")),
  CONTROL_51            = Enum (179, _("Control 51 General Purpose Controller 4 LSB")),
  CONTROL_52            = Enum (180, _("control-52")),
  CONTROL_53            = Enum (181, _("control-53")),
  CONTROL_54            = Enum (182, _("control-54")),
  CONTROL_55            = Enum (183, _("control-55")),
  CONTROL_56            = Enum (184, _("control-56")),
  CONTROL_57            = Enum (185, _("control-57")),
  CONTROL_58            = Enum (186, _("control-58")),
  CONTROL_59            = Enum (187, _("control-59")),
  CONTROL_60            = Enum (188, _("control-60")),
  CONTROL_61            = Enum (189, _("control-61")),
  CONTROL_62            = Enum (190, _("control-62")),
  CONTROL_63            = Enum (191, _("control-63")),
  // 7bit, literal channel controls
  CONTROL_64            = Enum (192, _("Control 64 Damper Pedal Switch (Sustain)")),
  CONTROL_65            = Enum (193, _("Control 65 Portamento Switch")),
  CONTROL_66            = Enum (194, _("Control 66 Sustenuto Switch")),
  CONTROL_67            = Enum (195, _("Control 67 Soft Switch")),
  CONTROL_68            = Enum (196, _("Control 68 Legato Pedal Switch")),
  CONTROL_69            = Enum (197, _("Control 69 Hold Pedal Switch")),
  CONTROL_70            = Enum (198, _("Control 70 Sound Variation")),
  CONTROL_71            = Enum (199, _("Control 71 Filter Resonance (Timbre)")),
  CONTROL_72            = Enum (200, _("Control 72 Sound Release Time")),
  CONTROL_73            = Enum (201, _("Control 73 Sound Attack Time")),
  CONTROL_74            = Enum (202, _("Control 74 Sound Brightness")),
  CONTROL_75            = Enum (203, _("Control 75 Sound Decay Time")),
  CONTROL_76            = Enum (204, _("Control 76 Vibrato Rate")),
  CONTROL_77            = Enum (205, _("Control 77 Vibrato Depth")),
  CONTROL_78            = Enum (206, _("Control 78 Vibrato Delay")),
  CONTROL_79            = Enum (207, _("Control 79 Sound Control 10")),
  CONTROL_80            = Enum (208, _("Control 80 General Purpose Switch 5")),
  CONTROL_81            = Enum (209, _("Control 81 General Purpose Switch 6")),
  CONTROL_82            = Enum (210, _("Control 82 General Purpose Switch 7")),
  CONTROL_83            = Enum (211, _("Control 83 General Purpose Switch 8")),
  CONTROL_84            = Enum (212, _("Control 84 Portamento Control (Note)")),
  CONTROL_85            = Enum (213, _("control-85")),
  CONTROL_86            = Enum (214, _("control-86")),
  CONTROL_87            = Enum (215, _("control-87")),
  CONTROL_88            = Enum (216, _("control-88")),
  CONTROL_89            = Enum (217, _("control-89")),
  CONTROL_90            = Enum (218, _("control-90")),
  CONTROL_91            = Enum (219, _("Control 91 Reverb Depth")),
  CONTROL_92            = Enum (220, _("Control 92 Tremolo Depth")),
  CONTROL_93            = Enum (221, _("Control 93 Chorus Depth")),
  CONTROL_94            = Enum (222, _("Control 93 Detune Depth")),
  CONTROL_95            = Enum (223, _("Control 95 Phase Depth")),
  CONTROL_96            = Enum (224, _("Control 96 Data Increment Trigger")),
  CONTROL_97            = Enum (225, _("Control 97 Data Decrement Trigger")),
  CONTROL_98            = Enum (226, _("Control 98 Non-Registered Parameter MSB")),
  CONTROL_99            = Enum (227, _("Control 99 Non-Registered Parameter LSB")),
  CONTROL_100           = Enum (228, _("Control 100 Registered Parameter MSB")),
  CONTROL_101           = Enum (229, _("Control 101 Registered Parameter LSB")),
  CONTROL_102           = Enum (230, _("control-102")),
  CONTROL_103           = Enum (231, _("control-103")),
  CONTROL_104           = Enum (232, _("control-104")),
  CONTROL_105           = Enum (233, _("control-105")),
  CONTROL_106           = Enum (234, _("control-106")),
  CONTROL_107           = Enum (235, _("control-107")),
  CONTROL_108           = Enum (236, _("control-108")),
  CONTROL_109           = Enum (237, _("control-109")),
  CONTROL_110           = Enum (238, _("control-110")),
  CONTROL_111           = Enum (239, _("control-111")),
  CONTROL_112           = Enum (240, _("control-112")),
  CONTROL_113           = Enum (241, _("control-113")),
  CONTROL_114           = Enum (242, _("control-114")),
  CONTROL_115           = Enum (243, _("control-115")),
  CONTROL_116           = Enum (244, _("control-116")),
  CONTROL_117           = Enum (245, _("control-117")),
  CONTROL_118           = Enum (246, _("control-118")),
  CONTROL_119           = Enum (247, _("control-119")),
  CONTROL_120           = Enum (248, _("Control 120 All Sound Off ITrigger")),
  CONTROL_121           = Enum (249, _("Control 121 All Controllers Off ITrigger")),
  CONTROL_122           = Enum (250, _("Control 122 Local Control Switch")),
  CONTROL_123           = Enum (251, _("Control 123 All Notes Off ITrigger")),
  CONTROL_124           = Enum (252, _("Control 124 Omni Mode Off ITrigger")),
  CONTROL_125           = Enum (253, _("Control 125 Omni Mode On ITrigger")),
  CONTROL_126           = Enum (254, _("Control 126 Monophonic Voices Mode")),
  CONTROL_127           = Enum (255, _("Control 127 Polyphonic Mode On ITrigger")),
};

// For musical tunings, see: http://en.wikipedia.org/wiki/Musical_tuning
enum MusicalTuning {
  // Equal Temperament: http://en.wikipedia.org/wiki/Equal_temperament
  OD_12_TET          = Enum (1, _("12 Tone Equal Temperament"),   // http://en.wikipedia.org/wiki/Equal_temperament
                             _("The most common tuning system for modern Western music, "
                               "is the twelve-tone equal temperament, abbreviated as 12-TET, "
                               "which divides the octave into 12 equal parts.")),
  OD_7_TET           = Enum (_("7 Tone Equal Temperament"),      // http://en.wikipedia.org/wiki/Equal_temperament
                             _("A fairly common tuning system is the seven-tone equal temperament tuning system, "
                               "abbreviated as 7-TET. It divides the octave into 7 equal parts using 171 cent steps.")),
  OD_5_TET           = Enum (_("5 Tone Equal Temperament"),      // http://en.wikipedia.org/wiki/Equal_temperament
                             _("A fairly common tuning system is the five-tone equal temperament tuning system, "
                               "abbreviated as 5-TET. It divides the octave into 5 equal parts using 240 cent steps.")),
  // Rational Intonation: http://en.wikipedia.org/wiki/Just_intonation
  DIATONIC_SCALE     = Enum (_("Diatonic Scale"),                 // http://en.wikipedia.org/wiki/Diatonic_scale
                             _("In music theory, a diatonic scale (also: heptatonia prima) is a seven-note "
                               "musical scale comprising five whole-tone and two half-tone steps. "
                               "The half tones are maximally separated, so between two half-tone steps "
                               "there are either two or three whole tones, repeating per octave.")), // Werckmeister I
  INDIAN_SCALE       = Enum (_("Indian Scale"),                   // http://en.wikipedia.org/wiki/Just_intonation#Indian_scales
                             _("Diatonic scale used in Indian music with wolf interval at Dha, close to 3/2")),
  PYTHAGOREAN_TUNING = Enum (_("Pythagorean Tuning"),             // http://en.wikipedia.org/wiki/Pythagorean_tuning
                             _("Pythagorean tuning is the oldest way of tuning the 12-note chromatic scale, "
                               "in which the frequency relationships of all intervals are based on the ratio 3:2. "
                               "Its discovery is generally credited to Pythagoras.")),
  PENTATONIC_5_LIMIT = Enum (_("Pentatonic 5-limit"),             // http://en.wikipedia.org/wiki/Pentatonic_scale
                             _("Pentatonic scales are used in modern jazz and pop/rock contexts "
                               "because they work exceedingly well over several chords diatonic "
                               "to the same key, often better than the parent scale.")),
  PENTATONIC_BLUES   = Enum (_("Pentatonic Blues"),               // http://en.wikipedia.org/wiki/Pentatonic_scale
                             _("The blues scale is the minor pentatonic with an additional augmented fourth, "
                               "which is referred to as the \"blues note\".")),
  PENTATONIC_GOGO    = Enum (_("Pentatonic Gogo"),                // http://en.wikipedia.org/wiki/Pentatonic_scale
                             _("The Pentatonic Gogo scale is an anhemitonic pentatonic scale used to tune the "
                               "instruments of the Gogo people of Tanzania.")),
  // Meantone Temperament: http://en.wikipedia.org/wiki/Meantone_temperament
  QUARTER_COMMA_MEANTONE = Enum (_("Quarter-Comma Meantone"),         // http://en.wikipedia.org/wiki/Quarter-comma_meantone
                                 _("Quarter-comma meantone was the most common meantone temperament in the "
                                   "sixteenth and seventeenth centuries and sometimes used later.")), // Werckmeister II
  SILBERMANN_SORGE   = Enum (_("Silbermann-Sorge Temperament"),   // http://de.wikipedia.org/wiki/Silbermann-Sorge-Temperatur
                             _("The Silbermann-Sorge temperament is a meantone temperament used for "
                               "Baroque era organs by Gottfried Silbermann.")),
  // Well Temperament: http://en.wikipedia.org/wiki/Well_temperament
  WERCKMEISTER_3     = Enum (_("Werckmeister III"),               // http://en.wikipedia.org/wiki/Werckmeister_temperament
                             _("This tuning uses mostly pure (perfect) fifths, as in Pythagorean tuning, but each "
                               "of the fifths C-G, G-D, D-A and B-F# is made smaller, i.e. tempered by 1/4 comma. "
                               "Werckmeister designated this tuning as particularly suited for playing chromatic music.")),
  WERCKMEISTER_4     = Enum (_("Werckmeister IV"),                // http://en.wikipedia.org/wiki/Werckmeister_temperament
                             _("In this tuning the fifths C-G, D-A, E-B, F#-C#, and Bb-F are tempered narrow by 1/3 comma, "
                               "and the fifths G#-D# and Eb-Bb are widened by 1/3 comma. The other fifths are pure. "
                               "Most of its intervals are close to sixth-comma meantone. "
                               "Werckmeister designed this tuning for playing mainly diatonic music.")),
  WERCKMEISTER_5     = Enum (_("Werckmeister V"),                 // http://en.wikipedia.org/wiki/Werckmeister_temperament
                             _("In this tuning the fifths D-A, A-E, F#-C#, C#-G#, and F-C are narrowed by 1/4 comma, "
                               "and the fifth G#-D# is widened by 1/4 comma. The other fifths are pure. "
                               "This temperament is closer to equal temperament than Werckmeister III or IV.")),
  WERCKMEISTER_6     = Enum (_("Werckmeister VI"),                // http://en.wikipedia.org/wiki/Werckmeister_temperament
                             _("This tuning is also known as Septenarius tuning is based on a division of the monochord "
                               "length into 196 = 7 * 7 * 4 parts. "
                               "The resulting scale has rational frequency relationships, but in practice involves pure "
                               "and impure sounding fifths. "
                               "Werckmeister described the Septenarius as a \"temperament which has nothing at all to do "
                               "with the divisions of the comma, nevertheless in practice so correct that one can be really "
                               "satisfied with it\".")),
  KIRNBERGER_3       = Enum (_("Kirnberger III"),                 // http://en.wikipedia.org/wiki/Johann_Philipp_Kirnberger_temperament
                             _("Kirnberger's method of compensating for and closing the circle of fifths is to split the \"wolf\" "
                               "interval known to those who have used meantone temperaments between four fifths instead, "
                               "allowing for four 1/4-comma wolves to take their place. "
                               "1/4-comma wolves are used extensively in meantone and are much easier to tune and to listen to. "
                               "Therefore, only one third remains pure (between C and E).")),
  YOUNG              = Enum (_("Young Temperament"),              // http://en.wikipedia.org/wiki/Young_temperament
                             _("Thomas Young devised a form of musical tuning to make the harmony most perfect in those keys which "
                               "are the most frequently used (give better major thirds in those keys), but to not have any unplayable keys. "
                               "This is attempted by tuning upwards from C a sequence of six pure fourths, "
                               "as well as six equally imperfect fifths.")),
};

// == Bse Constants ==
Const MIN_NOTE      = 0;
Const MAX_NOTE      = 131;          // 123
Const NOTE_VOID     = MAX_NOTE + 1; /// Value represents unparsable/unknown notes
Const KAMMER_NOTE   = 69;           /// Kammer note, representing the kammer frequency's MIDI note value for A' or A4
Const KAMMER_FREQ   = 440.0;        /// Pitch Standard, see also: https://en.wikipedia.org/wiki/A440_(pitch_standard)
Const KAMMER_OCTAVE = +1;           /// Octave number for MIDI A'
Const MIN_OCTAVE    = -4;           /// Octave of MIN_NOTE
Const MAX_OCTAVE    = +6;           /// Octave of MAX_NOTE
Const MIN_FINE_TUNE = -100;
Const MAX_FINE_TUNE = 100;
Const MIN_BPM       = 1;
Const MAX_BPM       = 1024;
Const MIN_TRANSPOSE = -72;
Const MAX_TRANSPOSE = +72;
Const GUI           = "r:w:G";
Const STORAGE       = "r:w:S";
Const STANDARD      = STORAGE ":G";
Const NOTEHINTS     = STANDARD ":note";
Const FINETUNEHINTS = STANDARD ":finetune";
Const VELOCITYHINTS = STANDARD ":velocity";

/// Stringeq - a variable length list of test strings.
sequence StringSeq {
  String string;
};

/// Representation of an image pixel sequence in ARGB format.
sequence PixelSeq {
  int32 argb = Num ("ARGB", "ARGB Format: (alpha << 24) | (red << 16) | (green << 8) | blue", STANDARD);
};

/// Representation of an icon pixel image.
record Icon {
  int32    width  = Range    ("Width",  "Width in pixels or 0 for no icon",  STANDARD, 0, 4096, 1, 0);
  int32    height = Range    ("Height", "Height in pixels or 0 for no icon", STANDARD, 0, 4096, 1, 0);
  PixelSeq pixels = Sequence ("Pixels", "Array of width*height ARGB pixels", STANDARD);
};

/// AuxData - record to describe entity attributes with "key=value" strings.
record AuxData {
  String    entity;             ///< Entity that has an auxillary data list.
  StringSeq attributes;         ///< List of "key=value" auxillary data strings.
};

/// AuxDataSeq - a variable length list of AuxData records.
sequence AuxDataSeq {
  AuxData aux_data;
};

/// Object to carry out IDL, API, signal, etc tests.
interface TestObject {
  int32         echo_test       (String msg);   ///< Echo custom message to stdout.
  // signal void echo_reply     (String msg);   ///< Signal emitted in response to echo_test().
};

enum UserMessageType {
  ERROR = 1,    ///< Indicate a message about an error condition.
  WARNING,      ///< Indicate a message about a possibly harmful condition.
  INFO,         ///< Indicate an informational message.
  DEBUG,        ///< Indicate a debugging message (usually insignificant).
};

/// Structure for submission of user interface messages from BSE.
record UserMessage {
  UserMessageType utype;        ///< Severity classification for this message.
  String          title;        ///< Usually GUI window title.
  String          text1;        ///< Primary message to the user, should be limited to 80-100 chars.
  String          text2;        ///< Explanatory (secondary) message no limitations recommended.
  String          text3;        ///< Possibly (technical) details or machine error message.
  String          label;        ///< Message class label, used to enable/disable this type of message.
};

/// Song timing configuration.
record SongTiming {
  int32   tick        = Range ("Current tick", "Song position timing applies to", STANDARD, 0, MAXINT31, 384, 0);
  float64 bpm         = Range ("BPM", "Beats per minute", STANDARD, MIN_BPM, MAX_BPM, 10, 120);
  // Signature
  int32   numerator   = Range ("Numerator", "Number of notes per measure", STANDARD, 1, 256, 2, 4);
  int32   denominator = Range ("Denominator", "Type of notes counted per measure", STANDARD, 1, 256, 2, 4);
  // Sequencer Timing
  int32   tpqn        = Range ("TPQN", "Ticks per quarter note", STANDARD, 1, MAXINT31, 12, 384);
  int32   tpt         = Range ("TPT", "Ticks per tact", STANDARD, 1, MAXINT31, 12, 384);
  // Playback Timing
  float64 stamp_ticks = Range ("Tick Increment", "Ticks per stamp increment (useful only during playback)", STANDARD, 1, MAXINT31, 12, 384);
};

/// A note description provides all needed details about a specific note. "
record NoteDescription
{
  MusicalTuning musical_tuning;
  int32    note            = Range ("Note", "", ":readwrite:note");
  int32    octave          = Range ("Octave", "", ":readwrite:octave");
  float64  freq            = Range ("Frequency", "", ":readwrite:freq");
  int32    finetune        = Range ("Finetune", "", ":readwrite:finetune", -100, +100, 10, 0);
  int32    semitone        = Range ("Semitone", "", ":readwrite", 0, 11, 1, 0);
  bool     upshift         = Bool ("Upshift", "Flag set for notes that correspond to a black piano key");
  int32    letter          = Range ("Letter", "International abbreviation letter for this note", ":readwrite", 32, 126, 1, 64);
  String   name            = String ("Name", "", ":readwrite");
};

// Forward declarations.
record PartLink;
sequence PartLinkSeq;
record TrackPart;
sequence TrackPartSeq;
interface Item;
interface Source;
interface Project;

/** Base type for all BSE objects.
 *
 * ### Events:
 * - **notify** - A notification event for property changes, the event field *detail* contains the property name.
 */
interface Object {
  String      uname      = String ("UName", "Unique object name", GUI);
  String      debug_name (); ///< Object name useful for debugging output.
  int32       unique_id  (); ///< Generate a unique stable ID for this object, similar to a hash of its address.
  void        notify     (String detail); ///< Emit notification event for object state or property changes.
  int64       proxy_id   (); ///< Helper ID for the old SfiGlue interface.
};

/// A list of Item or derived objects.
sequence ItemSeq {
  Item items;
};

/// A list of items suitable to set as a specific property value.
record PropertyCandidates {
  Info      blurb      = ("A structure describing tentative property values.");
  String    label;
  String    tooltip;
  ItemSeq   items;
  // List of types which may logically partition the list of items by type discrimination
  StringSeq partitions;
};

/// Base interface type for objects that can be added to a container.
interface Item : Object {
  Icon    icon = Record ("Icon", "State dependent icon representation of this item", "rw:G");
  Item    use               (); ///< Increment use count to keep an item alive.
  void    unuse             (); ///< Decrement use count for when an item is not needed anymore.
  void    set_name          (String name);       ///< Assign an item's name.
  Item    common_ancestor   (Item other);        ///< Find a common container (parent or grand-parent) of two items if any.
  bool    check_is_a        (String type_name);  ///< Check whether an item has a certain type.
  void    group_undo        (String group_name); ///< Request multiple modifying actions on an item to be grouped together as a single undo operation.
  void    ungroup_undo      (); ///< Ends the undo grouping opened up by a previous group-undo() call.
  Project get_project       (); ///< Retrieve an item's project.
  Item    get_parent        (); ///< Retrieve an item's parent.
  int32   get_seqid         (); ///< Retrieve an item's sequential ID. The sequential ID depends on the item's type an it's position inbetween siblings of the same type within it's immediate container.
  String  get_type          (); ///< Retrieve an item's type name.
  String  get_type_authors  (); ///< Retrieve authors of an item's type implementation.
  String  get_type_blurb    (); ///< Retrieve an item's type description.
  String  get_type_license  (); ///< Retrieve the license for an item's type implementation.
  String  get_type_name     (); ///< Retrieve an item's type name.
  String  get_uname_path    (); ///< Retrieve the project relative uname path for this item.
  String  get_name          (); ///< Retrieve an item's name.
  String  get_name_or_type  (); ///< Retrieve an item's name or type if it has no name.
  bool    internal          (); ///< Check whether an item is internal, i.e. owned by another non-internal item.
  bool    editable_property (String property); ///< Test whether a property is editable according to object state and property options.
  PropertyCandidates get_property_candidates (String property_name); ///< Retrieve tentative values for an item or item sequence property.
  // int32 seqid = Range ("Sequential ID", "", ":readwrite", 0, MAXINT31, 1);
};

/// Part specific note event representation.
record PartNote
{
  int32   id        = Num ("ID", "", 0, ":readwrite");
  int32   channel   = Range ("Channel", "", ":readwrite", 0, MAXINT31, 1);
  int32   tick      = Range ("Tick", "", ":readwrite", 0, MAXINT31, 1);
  int32   duration  = Range ("Duration", "Duration in number of ticks", ":readwrite", 0, MAXINT31, 1);
  int32   note      = Range ("Note", "", NOTEHINTS, MIN_NOTE, MAX_NOTE, 12, KAMMER_NOTE);
  int32   fine_tune = Range ("Fine Tune", "", FINETUNEHINTS, MIN_FINE_TUNE, MAX_FINE_TUNE, 1);
  float64 velocity  = Range ("Velocity", "", VELOCITYHINTS, 0, 1.0, 0.1, 1);
  bool    selected  = Bool ("Selected", "", ":readwrite", false);
};

/// A list of part note events.
sequence PartNoteSeq {
  PartNote part_notes;
};

/// Part specific control event representation.
record PartControl {
  int32          id           = Num ("ID", "", ":readwrite");
  int32          tick         = Range ("Tick", "", ":readwrite", 0, MAXINT31, 1);
  MidiSignal     control_type;
  float64        value        = Range ("Value", "", ":readwrite", -1, +1, 0.1);
  bool           selected     = Bool ("Selected", "", ":readwrite");
};

/// A list of part control events.
sequence PartControlSeq {
  PartControl pcontrols;
};

/// Data interface for containment of piano notes and MIDI effects.
interface Part : Item {
  PartControlSeq list_selected_controls    (MidiSignal control_type); ///< List all currently selected control events of a specific type.
  PartControlSeq list_controls             (int32 tick, int32 duration, MidiSignal control_type); ///< List all control events within a tick range.
  PartControlSeq get_channel_controls      (int32 channel, int32 tick, int32 duration, MidiSignal control_type); ///< Retrieve all control events of a specific type within range of a channel.
  PartControlSeq get_controls              (int32 tick, MidiSignal control_type); ///< Retrieve all control events of a specific type at specified tick.
  SongTiming     get_timing                (int32 tick); ///< Retrieve song timing information at a specific tick.
  int32          get_max_note              ();           ///< Retrieve the maximum note supported in this part.
  int32          get_min_note              ();           ///< Retrieve the minimum note supported in this part.
  int32          get_last_tick             ();           ///< Retrieve the maximum tick any control or note plus duration spans.
  Error          change_control            (int32 id, int32 tick, MidiSignal control_type, float64 value); ///< Change an existing control event within a part.
  Error          change_note               (int32 id, int32 tick, int32 duration, int32 note, int32 fine_tune, float64 velocity); ///< Change an existing note within a part.
  Error          delete_event              (int32 id); ///< Delete an existing event from a part.
  int32          insert_control            (int32 tick, MidiSignal control_type, float64 value); ///< Insert a new control event into a part.
  int32          insert_note               (int32 channel, int32 tick, int32 duration, int32 note, int32 fine_tune, float64 velocity); ///< Insert a new note into a part.
  int32          insert_note_auto          (int32 tick, int32 duration, int32 note, int32 fine_tune, float64 velocity); ///< Insert a new note into a part with automatic channel selection.
  bool           is_event_selected         (int32 id); ///< Check whether an event is selected.
  void           queue_controls            (int32 tick, int32 duration); ///< Queue updates for all control events and notes starting within the given range.
  void           queue_notes               (int32 tick, int32 duration, int32 min_note, int32 max_note); ///< Queue updates for all notes starting within the given rectangle.
  void           select_notes_exclusive    (int32 tick, int32 duration, int32 min_note, int32 max_note); ///< Select all notes within rectangle and deselect all others.
  void           select_controls_exclusive (int32 tick, int32 duration, MidiSignal control_type); ///< Select all control events within range and deselect all others.
  void           select_notes              (int32 tick, int32 duration, int32 min_note, int32 max_note); ///< Select all notes within rectangle.
  void           select_event              (int32 id); ///< Select an existing event.
  void           select_controls           (int32 tick, int32 duration, MidiSignal control_type); ///< Select all control events within range.
  void           deselect_notes            (int32 tick, int32 duration, int32 min_note, int32 max_note); ///< Deselect all notes within rectangle.
  void           deselect_event            (int32 id); ///< Deselect an existing event.
  void           deselect_controls         (int32 tick, int32 duration, MidiSignal control_type); ///< Deselect all controls within given range.
  PartNoteSeq list_notes_crossing (int32 tick, int32 duration); ///< List all notes within or crossing a tick range.
  PartNoteSeq list_notes_within   (int32 channel, int32 tick, int32 duration); ///< List all notes within a tick range.
  PartNoteSeq list_selected_notes (); ///< List all currently selected notes.
  PartNoteSeq check_overlap       (int32 tick, int32 duration, int32 note); ///< Check whether a note would overlap with neighbours.
  PartNoteSeq get_notes           (int32 tick, int32 note); ///< Retrieve all notes at a specific frequency or crossing a tick.
  PartLinkSeq list_links          (); ///< List all places where parts are used (linked) from tracks, sorted by tick.

  // signal void    range_changed             (int32 a, int32 b, int32 c, int32 d);
  // signal void    links_changed             ();
  // property int32 n_channels;
  // property int32 last_tick;
};

/// A list of Part or derived types.
sequence PartSeq {
  Part part;
};

/// A list of floating point values.
sequence FloatSeq {
  float64 floats;
};

/// Descriptor for a shared memory region.
record SharedMemory {
  int64  shm_creator;   ///< IPC id of the shared memory creator process.
  int64  shm_id;        ///< Identifier for the associated shared memory area.
  int64  shm_start;     ///< Shared memory area location.
  int64  shm_length;    ///< Shared memory area length in bytes
};

/// Bits representing a selection of probe sample data features.
record ProbeFeatures {
  bool          probe_range;
  bool          probe_energie;
  bool          probe_samples;
  bool          probe_fft;
};

/// Probe sample data.
record Probe {
  int32         channel;
  int64         block_stamp;
  float64       mix_freq;
  ProbeFeatures probe_features;
  float64       min;			// FIXME: rename to range_min
  float64       max;
  float64       energie;
  FloatSeq      sample_data;
  FloatSeq      fft_data;
};

/// A list of Probe records.
sequence ProbeSeq {
  Probe probes;
};

/// Realtime probe request specification.
record ProbeRequest {
  Item          source; // FIXME: use 'Source' here, but that's not fully defined in the C++ client bindings at this point
  int32         channel;
  float64	frequency;
  ProbeFeatures probe_features;
};

/// List of probe requests.
sequence ProbeRequestSeq {
  ProbeRequest probe_requests;
};

/// Layout of SignalMonitor fields within shared memory.
record MonitorFields {
  float64       min;                    ///< Minimum value of the last frame.
  float64       max;                    ///< Maximum value of the last frame.
  float64       energy;                 ///< Energy of the last frame.
  float64       tip;                    ///< Tip energy of the last couple frames.
  int64         gen;                    ///< Gneration counter, updated on every modification.
};

/// Interface for monitoring output signals.
interface SignalMonitor {
  int64         get_shm_id         ();                  ///< Identifier for the associated shared memory area.
  Source        get_osource        ();                  ///< Retrieve output module the SignalSnooper is connected to.
  int64         get_shm_offset     ();                  ///< Offset into shm_id for MonitorFields of @a ochannel.
  int32         get_ochannel       ();                  ///< Offset into shm_id for MonitorFields of @a ochannel.
  int64         get_mix_freq       ();                  ///< Mix frame at which SnoopFields values are calculated.
  int64         get_frame_duration ();                  ///< Frame duration in seconds for the calculation of SnoopFields values.
  void          set_probe_features (ProbeFeatures pf);  ///< Configure probe features.
  ProbeFeatures get_probe_features ();                  ///< Get configured probe features.
};

/// Base interface type for synthesis modules with input or output streams.
interface Source : Item {
  Source ichannel_get_osource (int32 input_channel, int32 input_joint); ///< Retrieve output module connected to a specific joint of an input channel.

  void clear_inputs ();  ///< Disconnect all module inputs.
  void clear_outputs (); ///< Disconnect all module outputs.
  bool has_output (int32 ochannel); ///< Check whether a module's output channel is connected.
  bool has_outputs (); ///< Check whether a module has output channel connections.
  String ichannel_blurb (int32 input_channel); ///< Get input channel description.
  int32 ichannel_get_n_joints (int32 input_channel); ///< Retrieve the number of inputs connected to an input channel.
  int32 ichannel_get_ochannel (int32 input_channel, int32 input_joint); ///< Retrieve output channel of the module connected to a specific joint of an input channel.
  String ichannel_ident (int32 input_channel); ///< Get canonical input channel name.
  String ichannel_label (int32 input_channel); ///< Get input channel name.
  bool is_joint_ichannel (String input_channel); ///< Check if an input channel is a joint (multi-connect) channel.
  bool is_joint_ichannel_by_id (int32 input_channel); ///< Check if an input channel is a joint (multi-connect) channel.
  bool is_prepared (); ///< Check whether a source is prepared for synthesis processing.
  int32 n_ichannels (); ///< Get the number of input channels of a module.
  int32 n_ochannels (); ///< Get the number of output channels of a module.
  String ochannel_blurb (int32 output_channel); ///< Get output channel description.
  String ochannel_ident (int32 output_channel); ///< Get canonical output channel name.
  String ochannel_label (int32 output_channel); ///< Get output channel name.

  /** Setup automation parameters for a property.
   * @param midi_channel The MIDI Channel from which automation events should be received, 0 designates the default MIDI channel
   * @param control_type The type of control events used for automation
   */
  Error       set_automation         (String property_name, int32 midi_channel, MidiControl control_type);
  MidiControl get_automation_control (String property_name); ///< Get control type from an automation property.
  int32       get_automation_channel (String property_name); ///< Get MIDI channel from an automation property.
  Error set_input (String input_channel, Source omodule, String output_channel); ///< Connect a module input to another module's output.
  Error set_input_by_id (int32 input_channel, Source omodule, int32 output_channel); ///< Connect a module input to another module's output.
  Error unset_input (String input_channel, Source omodule, String output_channel); ///< Disconnect a module input.
  Error unset_input_by_id (int32 input_channel, Source omodule, int32 output_channel); ///< Disconnect a module input.
  // signal void io_changed ();
  // float64 pos_x = Range ("Position X", "", STANDARD ":scale");
  // float64 pos_y = Range ("Position Y", "", STANDARD ":scale");
  /** Set the x and y position of a module.
   * In contrast to setting the position through ordinary object property
   * setters, this function will not update the module position if the passed
   * in arguments are sufficiently equal to the values already set on the
   * object. As such, it does not record an extra undo step for setting
   * properties to values they already have and if necessary turns setting
   * of x and y positions into an atomic undo operation.
   */
  void set_pos (float64 x_pos, float64 y_pos);
  /// Retrieve the current mixing frequency used for probes.
  int32       get_mix_freq   ();
  /// Query sample probes from a number of sources.
  void        request_probes (ProbeRequestSeq prseq);
  /// Signal arrival of new probe values.
  // signal void probes         (ProbeSeq a);

  /// Create signal monitor for an output channel.
  SignalMonitor create_signal_monitor (int32 ochannel);
};

/// Source module for merging multiple synthesis contexts, used to implement polyphony.
interface ContextMerger : Source {
};

/// Base interface type for containers of Item derived types.
interface Container : Source {
  Item lookup_item (String uname); ///< Find an immediate child of a container by name (unique per container child).
  Item get_item    (String item_type, int32 seq_id); ///< Retrieve the immediate child of type @a item_type by its sequential id (the 'nth' child).
  ItemSeq list_children (); ///< List all immediate children of a container.
};

/// Base interface type for Item managers.
interface Super : Container {
};

/// A list of Super type objects.
sequence SuperSeq {
  Super supers;
};

/// Base interface type for all kinds of synthesis networks.
interface SNet : Super {
  bool        supports_user_synths ();                ///< Check whether users may edit synthesis modules of this network.
  Error       can_create_source (String module_type); ///< Check whether inserting a new module into a synthesis network is possible.
  Source      create_source     (String module_type); ///< Insert a new module into a synthesis network.
  Error       remove_source     (Source module);      ///< Remove an existing module from its synthesis network.
  // signal void port_unregistered ();                   ///< Signal that notifies when a named output port is unregistered.
  group _("Playback Settings") {
    bool      auto_activate = Bool (_("Auto Activate"),
                                    _("Automatic activation only needs to be enabled for synthesis networks that don't "
                                      "use virtual ports for their input and output"),
                                    STANDARD, true);
  };
};

/// Customizable synthesis (filter) network container.
interface CSynth : SNet {
};

/// Synthesizer module for embedding (rerouting input and output) of another synthesizer network (SNet).
interface SubSynth : Source {
  // CSynth snet       = Object ("Synthesizer",   "Synthesis network to use as embedded sub network", STANDARD ":unprepared");
  // String in_port_1  = String ("Input Port 1",  "Output port name to interface from",               STANDARD ":skip-default");
  // String out_port_1 = String ("Output Port 1", "Input port name to interface to",                  STANDARD ":skip-default");
  // String in_port_2  = String ("Input Port 2",  "Output port name to interface from",               STANDARD ":skip-default");
  // String out_port_2 = String ("Output Port 2", "Input port name to interface to",                  STANDARD ":skip-default");
  // String in_port_3  = String ("Input Port 3",  "Output port name to interface from",               STANDARD ":skip-default");
  // String out_port_3 = String ("Output Port 3", "Input port name to interface to",                  STANDARD ":skip-default");
  // String in_port_4  = String ("Input Port 4",  "Output port name to interface from",               STANDARD ":skip-default");
  // String out_port_4 = String ("Output Port 4", "Input port name to interface to",                  STANDARD ":skip-default");
  // String in_port_5  = String ("Input Port 5",  "Output port name to interface from",               STANDARD ":skip-default");
  // String out_port_5 = String ("Output Port 5", "Input port name to interface to",                  STANDARD ":skip-default");
  // String in_port_6  = String ("Input Port 6",  "Output port name to interface from",               STANDARD ":skip-default");
  // String out_port_6 = String ("Output Port 6", "Input port name to interface to",                  STANDARD ":skip-default");
  // String in_port_7  = String ("Input Port 7",  "Output port name to interface from",               STANDARD ":skip-default");
  // String out_port_7 = String ("Output Port 7", "Input port name to interface to",                  STANDARD ":skip-default");
  // String in_port_8  = String ("Input Port 8",  "Output port name to interface from",               STANDARD ":skip-default");
  // String out_port_8 = String ("Output Port 8", "Input port name to interface to",                  STANDARD ":skip-default");
};

/// Interface for sequencing information and links to Part objects.
interface Track : ContextMerger {
  SongTiming get_timing  (int32 tick);            ///< Retrieve song timing information at a specific tick.
  int32      insert_part (int32 tick, Part part); ///< Insert Part into Track at @a tick, returns the corresponding link id.
  void       remove_tick (int32 tick);            ///< Remove Part at specified @a tick from a track.
  void       remove_link (int32 id);              ///< Remove a specific part link by ID from a track.

  PartSeq      list_parts_uniq ();              ///< List all parts contained in a track.
  TrackPartSeq list_parts ();                   ///< List parts scheduled in a track, sorted by tick.
  Part         get_part (int32 tick);           ///< Get the part starting at a specific tick position.
  int32        get_last_tick ();                ///< Retrieve the last tick for this track.
  Error        ensure_output ();                ///< Ensure the track has an output connection to a bus.
  /// Get the output module of a track.
  /// The output of this module is the merged result from all polyphonic voices and has all track specific alterations applied.
  Source       get_output_source ();

  // property bool muted;          ///< _("Mute this track by ignoring it in the sequencer.")
  // property CSynth snet;         ///< _("Synthesis network to be used as instrument.")
  // property Wave wave;           ///< _("Wave to be used as instrument.")
  // property int32 midi_channel;  ///< _("Midi channel assigned to this track, 0 uses internal per-track channel.")
  // property int32 n_voices;      ///< _("Maximum number of voices for simultaneous playback.")
  // property CSynth pnet;         ///< _("Synthesis network to be used as postprocessor.")
  ItemSeq outputs;      ///< _("Mixer busses used as output for this track.")
};

/// Record representing the use of a Part within a Track at a specific position.
record PartLink {
  Track track;
  int32 tick     = Range ("Tick", "", STANDARD, 0, MAXINT31, 384);
  Part  part;
  int32 duration = Range ("Duration", "", STANDARD, 0, MAXINT31, 384);
  // int32 count; // 1 + repetitions
};

/// Sequence of PartLink records.
sequence PartLinkSeq {
  PartLink plinks;
};

/// Structure linking to a Track from within a Part.
record TrackPart {
  int32 tick     = Range ("Tick", "", STANDARD, 0, MAXINT31, 384);
  Part  part;
  int32 duration = Range ("Duration", "", STANDARD, 0, MAXINT31, 384);
};

/// Sequence of TrackPart records.
sequence TrackPartSeq {
  TrackPart parts;
};

/// Interface for effect stacks and per-track audio signal routing to the master output.
interface Bus : SubSynth {
  Error ensure_output    ();            ///< Ensure that a bus has an output connection.
  Error connect_bus      (Bus bus);     ///< Add a bus to the input list of a bus.
  Error connect_track    (Track track); ///< Add a track to the input list of a bus.
  Error disconnect_bus   (Bus bus);     ///< Remove a bus from the input list of a bus.
  Error disconnect_track (Track track); ///< Remove a track from the input list of a bus.
  // ItemSeq   inputs        = Object ("Input Signals", "Synthesis signals (from tracks and busses) used as bus input", GUI ":item-sequence");
  // ItemSeq   outputs       = Object ("Output Signals", "Mixer busses used as output for synthesis signals", GUI ":item-sequence");
  // CSynth    snet          = Object ("SNet", "Synthesis network used internally to implement effect stack", READWRITE ":skip-undo");
  // bool      mute          = Bool   ("Mute", "Mute: turn off the bus volume",    STANDARD ":skip-default", FALSE);
  // bool      solo          = Bool   ("Solo", "Solo: mute all other busses",      STANDARD ":skip-default", FALSE);
  // bool      sync          = Bool   ("Sync", "Synchronize left and right volume", STANDARD ":skip-default", TRUE);
  // float64   left_volume   = Num    ("Left Volume",  "Volume adjustment in decibel of left bus channel",  STANDARD ":scale:db-volume");
  // float64   right_volume  = Num    ("Right Volume", "Volume adjustment in decibel of right bus channel", STANDARD ":scale:db-volume");
  // bool      master_output = Bool   ("Master Output", "", STORAGE ":skip-default", FALSE);
};

/// Interface for Track and Part objects, as well as meta data for sequencing.
interface Song : SNet {
  SongTiming get_timing              (int32 tick);  ///< Retrieve song timing information at a specific tick.
  Track      find_any_track_for_part (Part part);   ///< Find the first track that contains part, suitable to check for orphan parts.
  Bus        create_bus              ();            ///< Create a new mixer bus for a Song.
  void       remove_bus              (Bus bus);     ///< Delete a mixer bus from a Song.
  Part       create_part             ();            ///< Create a new Part in a Song.
  void       remove_part             (Part part);   ///< Delete a Part from a Song.
  Track      create_track            ();            ///< Create a new Track for a Song.
  void       remove_track            (Track track); ///< Delete a Track from a Song.
  Bus        ensure_master_bus       ();            ///< Retrieve master output bus of a song, will create one if it doesn't exist.
  void       ensure_track_links      ();            ///< Ensure that each part in a song is inserted into at least one track.
  Track      find_track_for_part     (Part part);   ///< Find a track suitable for playing notes of a given part.
  Bus        get_master_bus          ();            ///< Retrieve master output bus of a song if it exists.
  /// Synthesize a note on a song of an active project.
  void       synthesize_note         (Track track, int32 duration, int32 note, int32 fine_tune, float64 velocity);
  // signal void   pointer_changed (int32 a);
  // group _("Timing") {
  // int32   tpqn          = Range  ("Ticks", "Number of ticks per quarter note", STANDARD, 384, 384, 0, 384);
  // int32   numerator     = Range  ("Numerator", "Measure numerator", STANDARD, 1, 256, 1, 4);
  // int32   denominator   = Range  ("Denominator", "Measure denominator, must be a power of 2", STANDARD, 1, 256, 1, 4);
  // float64 bpm           = Range  ("BPM", "Beats per minute", STANDARD, MIN_BPM, MAX_BPM, 10, 120);
  // };
  // group _("MIDI Instrument") {
  // CSynth  pnet          = Object ("Postprocessor", "Synthesis network to be used as postprocessor", STANDARD);
  // };
  // bool  loop_enabled  = Bool  ("Loop Enabled", "", STORAGE, FALSE);
  // int32 loop_left     = Range ("Loop Left", "", STORAGE, -1, MAXINT31, 384, -1);
  // int32 loop_right    = Range ("Loop Right", "", STORAGE, -1, MAXINT31, 384, -1);
  // int32 tick_pointer  = Range ("Tick Pointer", "", STORAGE, -1, MAXINT31, 384, -1);
  group _("Timing") {
    float64 bpm           = Range  (_("BPM"), _("Beats per minute"), STANDARD  ":scale", MIN_BPM, MAX_BPM, 10, 120);
  };
  group _("Tuning") {
    MusicalTuning musical_tuning = Enum (_("Musical Tuning"),
                                         _("The tuning system which specifies the tones or pitches to be used. "
                                           "Due to the psychoacoustic properties of tones, various pitch combinations can "
                                           "sound \"natural\" or \"pleasing\" when used in combination, the musical "
                                           "tuning system defines the number and spacing of frequency values applied."),
                                         STANDARD  ":unprepared");
  };
};

///< Structure containing meta data for multi wave samples.
record SampleFileInfo {
  String     file    = String ("Filename", "", STANDARD);
  int64      size    = Range ("File Size", "File size in bytes", ":readwrite", 0, MAXINT63);
  int64      mtime   = Range ("MTime", "Last modification time in seconds", ":readwrite", 0, MAXINT63);
  String     loader  = String ("Loader", "Sample loader implementation", STANDARD);
  StringSeq  waves   = Sequence ("Waves", "List of embedded waves", STANDARD);
  Error      error   = Enum ("Error", "Indicator for errors during sample operation", STANDARD);
};

/// Interface for editable PCM wave samples.
interface EditableSample : Item {
  /** Collect statistics from sample blocks as (minimum, maximum) pairs.
   * @param voffset       Offset of first stat block
   * @param offset-scale  Factor to scale voffset increments with
   * @param block-size    Block size to compute stat pairs from
   * @param stepping      Stepping within a stat block
   * @param max-pairs     Maximum number of (min, max) pairs to collect
   * @return              Block of samples
   */
  FloatSeq    collect_stats  (int64 voffset, float64 offset_scale, int64 block_size, int64 stepping, int64 max_pairs);
  void        close          (); ///< Close an opened sample.
  int64       get_length     (); ///< Return the number of values in the sample.
  int64       get_n_channels (); ///< Return the number of channels in the sample.
  float64     get_osc_freq   (); ///< Return the oscillator frequency for the sample.
  Error       open           (); ///< Open the sample for reading.
  //signal void changed        (); ///< Signal indicating all sorts of possible changes.
};

/// Interface for PCM wave samples.
interface Wave : Source {
  float64        chunk_get_mix_freq    (int32 chunk_index); ///< Retrieve mixing frequency of a wave chunk.
  float64        chunk_get_osc_freq    (int32 chunk_index); ///< Retrieve oscillating frequency of a wave chunk.
  int32          n_wave_chunks         ();                  ///< Get the number of wave chunks of a wave.
  EditableSample use_editable          (int32 chunk_index); ///< Retrieve an editable sample object for a wave chunk.
};

/// Interface serving as container for Wave objects.
interface WaveRepo : Super {
  Error load_file   (String file_name);         ///< Load wave from file.
  void  remove_wave (Wave wave);                ///< Remove a wave from repository.
};

/// A list of part note events.
interface WaveOsc;
sequence WaveOscSeq {
  WaveOsc wave_oscs;
};

/// Oscillator module for wave files.
interface WaveOsc : Source {
  /// Seek a list of wave oscillators to a pcm position given in percentage. The oscillators will seek to the given position synchronously.
  void sync_seek_perc           (float64 pos_perc, WaveOscSeq wosc_seq);
  void request_pcm_position     ();                       ///< Request emission of the ::notify_pcm_position signal.
  void set_from_editable_sample (EditableSample esample); ///< Set wave to play from editable sample, bypassing undo and storage mechanisms.
  // signal void notify_pcm_position      (int64 timestamp, int64 position); ///< Notification signal containing the current PCM play position pointer.
  // Wave    wave           = ("Wave", "Wave used as oscillator source", STANDARD);
  // int64   channel        = Range ("Channel", "The audio channel to play, usually 1 is left, 2 is right", ":readwrite", 1, 256);
  // float64 fm_perc        = Range ("Input Modulation [%]", "Modulation Strength for linear frequency modulation", STANDARD  ":scale", 0, 100, 10);
  // bool    exponential_fm = Bool ("Exponential FM", "Perform exponential frequency modulation instead of linear", STANDARD, false);
  // float64 fm_n_octaves   = Range ("Octaves", "Number of octaves to be affected by exponential frequency modulation", STANDARD ":scale", 0, 3, 1);
};

/// Interface for sound fonts
interface SoundFont : Container {
};

interface SoundFontRepo : Super {
  Error load_file         (String file_name);         ///< Load sound font from file.
  Error remove_sound_font (SoundFont sound_font);     ///< Remove a sound font from repository.
};

/// Interface for MIDI event notification.
interface MidiNotifier : Item {
};

/// Interface for MIDI synthesis networks.
interface MidiSynth : SNet {
};

/// Enumeration describing the current activation and playback state of a project.
enum ProjectState {
  INACTIVE,     ///< The project is not yet hooked to the sound engine.
  ACTIVE,       ///< The sound engine is activated (rnuning) for this project.
  PLAYING       ///< The project is active and the sequencer is running.
};

/// Projects support loading, saving, playback and act as containers for all other sound objects.
interface Project : Container {
  // signal void  state_changed       (ProjectState newstate); ///< Signal notifies of project state changes.
  ProjectState get_state           (); ///< Retrieve the current project activation/playback state.
  void         change_name         (String name); ///< Change a project name without recording undo steps.
  Error        play                (); ///< Activate a project and start project playback (an already playing project is first halted).
  Error        activate            (); ///< Activate a project, precondition to start playback.
  bool         can_play            (); ///< Check whether project playback would makes sense.
  bool         is_playing          (); ///< Check whether a project is currently playing (song sequencing).
  bool         is_active           (); ///< Check whether a project is active (currently synthesizing).
  void         start_playback      (); ///< Start playback in an activated project.
  void         stop_playback       (); ///< Stop project playback.
  void         deactivate          (); ///< Deactivate the project, automatically stop playback.
  void         stop                (); ///< Stop project playback and deactivate project.
  void         auto_deactivate     (int32 msec_delay); ///< Automatically deactivate a few milliseconds after playback stopped.
  int32        undo_depth          (); ///< Check whether a project can perform undo steps.
  void         undo                (); ///< Undo a previous operation in a project.
  int32        redo_depth          (); ///< Get the number of times redo can be called on the project.
  void         redo                (); ///< Redo a previously undone operation in a project.
  void         clear_undo          (); ///< Delete all recorded undo or redo steps.
  void         clean_dirty         (); ///< Clear a project's dirty flags.
  bool         is_dirty            (); ///< Check whether a project needs saving.
  SuperSeq     get_supers          (); ///< Retrieve all Super type objects of this project.
  Error        store_bse           (Super super, String file_name, bool self_contained);
  Song         create_song         (String name); ///< Create a song for this project.
  WaveRepo     get_wave_repo       ();            ///< Retrieve the project's unique wave repository.
  SoundFontRepo get_sound_font_repo ();            ///< Retrieve the project's unique sound font repository.
  CSynth       create_csynth       (String name); ///< Create a synthsizer network for this project.
  MidiSynth    create_midi_synth   (String name); ///< Create a MIDI synthesizer network for this project.
  MidiNotifier get_midi_notifier   ();            ///< Retrieve the project's midi notifier object.
  void         remove_snet         (SNet snet);   ///< Remove an existing synthesizer network from this project.
  Error        restore_from_file   (String file_name); ///< Load a project from file.
  /// Inject a MIDI control event into the project's MIDI receiver.
  void         inject_midi_control (int32 midi_channel, int32 midi_control, float64 control_value);
  Error        import_midi_file    (String file_name); ///< Import a song from a MIDI file.
  //Item    find_item (String uname_path); ///< Find an item within a project, given its uname path.
  /// List uname paths for all items of a specified type within a project.
  /// By their uname paths, items are uniquely identifyable within a project.
  //StringSeq list_uname_paths (String item_type);
  /// Retrieve all items of a specific type within a project with matching uname.
  //ItemSeq match_items_by_uname (String item_type, String uname);
  /// Save super objects of a project into a BSE file.
  /// If no Super is specified, the project itself is stored.
  /// The references to other objects (e.g. samples) can be stored
  /// by reference (self_contained=false) or embedded in the output
  /// file (self_contained=true).

};

/// Interface for writing PCM wave data.
interface PcmWriter : Item {
};

/// Categories describe useful type entities.
record Category
{
  int32  category_id = Num ("Category ID", "", ":readwrite");
  String category;
  int32  mindex;
  int32  lindex;
  String otype;
  Icon   icon;
};

/// Sequence of Category records.
sequence CategorySeq {
  Category cats;
};

/** Main Bse remote origin object.
 * The Bse::Server object controls the main BSE thread and keeps track of all objects
 * used in the BSE context.
 *
 * ### Events:
 * - **enginechange** - A notification event for DSP engine changes, the event field *active* contains the activateion state.
 */
interface Server : Container {
  // signal void   user_message      (UserMessage umsg);   ///< Notification signal for user messages from BSE.
  void          send_user_message (UserMessage umsg);   ///< Send a user messages from BSE.
  TestObject    get_test_object ();                     ///< Retrieve object for API, signal, etc tests.
  Object        from_proxy      (int64 proxyid);        ///< Find an Object from its associated BseObject proxy id.
  bool          engine_active   ();                     ///< Retrieve DSP engine activateion state, see also: "enginechange" Event.
  String        get_mp3_version ();                     ///< Retrieve BSE MP3 handler version.
  String        get_vorbis_version ();                  ///< Retrieve BSE Vorbis handler version.
  SharedMemory  get_shared_memory  (int64 id);          ///< Retrieve SharedMemory from id.
  String        get_ladspa_path ();                     ///< Retrieve ladspa search path.
  String        get_plugin_path ();                     ///< Retrieve plugin search path.
  String        get_instrument_path ();                 ///< Retrieve instrument search path.
  String        get_sample_path ();                     ///< Retrieve sample search path.
  String        get_effect_path ();                     ///< Retrieve effect search path.
  String        get_demo_path ();                       ///< Retrieve demo search path.
  String        get_custom_instrument_dir ();           ///< Retrieve user specific instruments directory.
  String        get_custom_effect_dir ();    ///< Retrieve user specific effects directory.
  String        get_version ();              ///< Retrieve BSE version.
  void          save_preferences ();         ///< Save the bse-preferences property to disk.
  void          register_ladspa_plugins();   ///< Register LADSPA (Linux Audio Developer's Simple Plugin API) plugins asynchronously, DEPRECATED.
  void          register_core_plugins();     ///< Register core plugins asynchronously, DEPRECATED.
  void          load_assets();               ///< Register plugins and scripts immediately.
  bool          preferences_locked();        ///< Returns whether the bse-preferences property is currently locked against modifications or not.
  bool          can_load (String file_name); ///< Check whether a loader can be found for a wave file.
  void          start_recording (String wave_file, float64 n_seconds); ///< Start recording to a WAV file.
  Project       create_project (String project_name); ///< Create a new project (name is modified to be unique if necessary.
  void          destroy_project (Project project);    ///< Destroy a previously created new project.
  AuxDataSeq     list_module_types ();                   ///< A list of Source type names for create_source().
  AuxData        find_module_type  (String module_type); ///< Retrieve info about a Source type names.
  Icon           module_type_icon  (String module_type); ///< Retrieve the icon associated with a module type.
  SampleFileInfo sample_file_info  (String file_name); ///< Load sample file info from file.

  /// Describe a note, providing information about its octave, semitone, frequency, etc.
  NoteDescription note_describe (MusicalTuning musical_tuning, int32 note, int32 fine_tune);
  // Describe a note, given its frequency.
  NoteDescription note_describe_from_freq (MusicalTuning musical_tuning, float64 freq);
  /// Describe a note, given its semitone, octave and fine tune.
  NoteDescription note_construct (MusicalTuning musical_tuning, int32 semitone, int32 octave, int32 fine_tune);
  /// Describe a note, given its name and octave offset.
  NoteDescription note_from_string (MusicalTuning musical_tuning, String name);
  /// Retrieve the note of a certain frequency.
  int32           note_from_freq (MusicalTuning musical_tuning, float64 frequency);
  /// Retrieve the frequency of a certain note.
  float64         note_to_freq (MusicalTuning musical_tuning, int32 note, int32 fine_tune);

  CategorySeq category_match_typed (String pattern, String type_name); ///< List BSE categories according to a pattern and type match.
  CategorySeq category_match       (String pattern);                   ///< List BSE categories according to a pattern match.

  /// Helper for Wave PCM positioning.
  int64       tick_stamp_from_systime (int64 systime_usecs);
};

} // Bse
